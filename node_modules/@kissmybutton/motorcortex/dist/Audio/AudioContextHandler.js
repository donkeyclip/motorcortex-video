"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _base64ToArrayBuffer(base64) {
  var binary_string = window.atob(base64);
  var len = binary_string.length;
  var bytes = new Uint8Array(len);

  for (var i = 0; i < len; i++) {
    bytes[i] = binary_string.charCodeAt(i);
  }

  return bytes.buffer;
}

var datamcidRegex = /\[data(-mcid="+\w+")+\]/g;

var Helper = require('../_coreUtils/Helper');

var helper = new Helper();

var AudioNode = require('./helpers/AudioNode');

var PubSub =
/*#__PURE__*/
function () {
  function PubSub() {
    _classCallCheck(this, PubSub);

    this.subscribers = [];
  }

  _createClass(PubSub, [{
    key: "sub",
    value: function sub(id, method) {
      this.subscribers.push(method);
    }
  }, {
    key: "pub",
    value: function pub(argument) {
      for (var i = 0; i < this.subscribers.length; i++) {
        this.subscribers[i](argument);
      }
    }
  }]);

  return PubSub;
}();
/**
 * Specs:
 * AudioContext Handler keeps all the audio sources.
 * The audio sources are passed in the following format:
 * - src (the source of the sound)
 * - base64 (boolean, defaults to false. If the sound is base64 it's been treated
 *      in a different way)
 * - id (must be unique)
 * - classes (an array of belonging classes)
 *
 * The SoundContextHanlder creates a media element of the following format:
 * media: {
 *  src
 *  id
 *  classes
 *  base64
 *  buffer
 *  nodes: {
 *      stereo
 *      highpass
 *      lowpass
 *      gain
 *      audioNode
 *  }
 * }
 *
 * Finally the SoundContextHandler has its own nodes (the master) which look like this:
 * master: {
 *      stereo
 *      highpass
 *      lowpass
 *      gain
 * }
 **/


var AudioContextHandler =
/*#__PURE__*/
function () {
  function AudioContextHandler() {
    var _this = this;

    var audioSources = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var masterNode = arguments.length > 1 ? arguments[1] : undefined;

    _classCallCheck(this, AudioContextHandler);

    // variables to be used for checking context rediness
    this.totalSources = audioSources.length; // initialisation of the final audio resources colleciton

    this.audioSources = {};
    this.elementsByMCID = {}; // iterate on audioSource to create the audioSources collection

    var _loop = function _loop(i) {
      var audioSource = audioSources[i];
      var audioResource = {
        mcid: audioSource.mcid || helper.getAnId(),
        id: audioSource.id,
        src: audioSource.src,
        classes: audioSource.classes || [],
        base64: audioSource.base64 || false,
        pubSub: new PubSub(),
        soundLoaded: false,
        startValues: audioSource.startValues || {}
      };
      _this.audioSources[audioResource.id] = audioResource;
      _this.elementsByMCID[audioResource.mcid] = audioResource;

      if (audioSource.base64 === true) {
        helper.getAudioContext().decodeAudioData(_base64ToArrayBuffer(audioSource.src), function (buffer) {
          _this._setBuffer(audioResource, buffer, masterNode);
        });
      } else {
        var request = new XMLHttpRequest();
        request.open('GET', audioResource.src, true);
        request.responseType = 'arraybuffer'; // Decode asynchronously

        _this.soundLoaded = false;

        request.onload = function () {
          helper.getAudioContext().decodeAudioData(request.response, function (buffer) {
            _this._setBuffer(audioResource, buffer, masterNode);
          }, _this.onError);
        };

        request.send();
      }
    };

    for (var i = 0; i < audioSources.length; i++) {
      _loop(i);
    }

    this.context = {
      document: document,
      window: window,
      rootElement: document.body,
      unmount: function unmount() {},
      masterNode: masterNode,
      audioContext: helper.getAudioContext(),
      getElements: this.getElements.bind(this),
      getMCID: this.getMCID.bind(this),
      setMCID: this.setMCID.bind(this),
      getElementSelectorByMCID: this.getElementSelectorByMCID.bind(this),
      getElementByMCID: this.getElementByMCID.bind(this)
    };
  }

  _createClass(AudioContextHandler, [{
    key: "_setBuffer",
    value: function _setBuffer(audioResource, buffer, masterNode) {
      audioResource.soundLoaded = true;
      audioResource.buffer = buffer;
      audioResource.effectsAudioNode = new AudioNode();
      audioResource.effectsAudioNode.connect(masterNode.input);
      audioResource.pubSub.pub();
    }
  }, {
    key: "getElementByMCID",
    value: function getElementByMCID(mcid) {
      if (Object.prototype.hasOwnProperty.call(this.elementsByMCID, mcid)) {
        return this.elementsByMCID[mcid];
      } else {
        return null;
      }
    }
  }, {
    key: "getElements",
    value: function getElements(selector) {
      if (selector.charAt(0) === "~") {
        selector = selector.substr(1);

        if (selector.charAt(0) === "#") {
          if (Object.prototype.hasOwnProperty.call(this.audioSources, selector.substr(1))) {
            return [this.audioSources[selector.substr(1)]];
          } else {
            return [];
          }
        } else if (selector.charAt(0) === ".") {
          var className = selector.substr(1);
          var toReturn = [];

          for (var source in this.audioSources) {
            if (source.classes.indexOf(className) >= 0) {
              toReturn.push(source);
            }
          }

          return toReturn;
        }
      } else if (datamcidRegex.exec(selector)) {
        var mcid = selector.split('"')[1];
        return this.elementsByMCID[mcid];
      } else {
        return [];
      }
    }
  }, {
    key: "getMCID",
    value: function getMCID(element) {
      return element.mcid;
    }
  }, {
    key: "setMCID",
    value: function setMCID(element, mcid) {
      element.mcid = mcid;
    }
  }, {
    key: "getElementSelectorByMCID",
    value: function getElementSelectorByMCID(mcid) {
      return "[data-mcid=\"".concat(mcid, "\"]");
    }
  }]);

  return AudioContextHandler;
}();

module.exports = AudioContextHandler;