"use strict";

var Helper = require('./Helper');

var helper = new Helper();

function IncidentFromDefinition(definition) {
  if (definition === null) {
    helper.error("IncidentFromDefinition expects the defintion parameter");
    return false;
  }

  var theNewIncident = new definition.Incident(definition.attrs, definition.props);
  theNewIncident.plugin_channel_class = definition.plugin_channel_class;
  theNewIncident.mc_plugin_npm_name = definition.mc_plugin_npm_name;
  constructIncidents(theNewIncident, definition);
  return theNewIncident;
}

function constructIncidents(parentIncident, incidentDefinition) {
  // TODO log failed incidents re-creation on the final result
  if (parentIncident.hasIncidents) {
    for (var i = 0; i < incidentDefinition.incidents.length; i++) {
      var incidentItem = incidentDefinition.incidents[i]; // incidentItem is an object:

      /*
      {
          id
          millisecond
          incident
      }
      */

      var theNewIncident = new incidentItem.incident.Incident(incidentItem.incident.attrs, incidentItem.incident.props);
      theNewIncident.plugin_channel_class = incidentItem.incident.plugin_channel_class;
      theNewIncident.mc_plugin_npm_name = incidentItem.incident.mc_plugin_npm_name;
      parentIncident.addIncident(theNewIncident, incidentItem.millisecond); // a special check for a special case. While Group objects maintain their reference
      // even after their entrance on the clip, Clips (as Incidents) don't as they get
      // turned to ElementClipSplitter. Thus in the one case is ok to add Incidents
      // directly to the original reference while on the other we should get from
      // the parent the reference to the altered object created so we can add Incidents

      if (theNewIncident.isTheClip) {
        constructIncidents(parentIncident.getIncidentById(theNewIncident.id), incidentItem.incident);
      }

      constructIncidents(theNewIncident, incidentItem.incident);
    }
  }
}

module.exports = IncidentFromDefinition;