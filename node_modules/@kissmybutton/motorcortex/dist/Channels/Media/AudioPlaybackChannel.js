"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var ClipsChannel = require('../Clip/ClipsChannel');

var _filter = require('../../../lodash-custom-build/modularize/lodash.filter/index.js');

var dataSeparator = "|||";

var Helper = require('../../_coreUtils/Helper');

var helper = new Helper();

var AudioPlaybackChannel =
/*#__PURE__*/
function (_ClipsChannel) {
  _inherits(AudioPlaybackChannel, _ClipsChannel);

  function AudioPlaybackChannel(props) {
    var _this;

    _classCallCheck(this, AudioPlaybackChannel);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AudioPlaybackChannel).call(this, props)); // keeps the list of the ids of MediaIncidents that are currently been played
    // in the form `${id}|||$[contextId}`

    _this.playingIncidentsIds = []; // when the Channel's Clip enters the transitional state the Channel ignores
    // moveTos. When the transition ends though, no matter the currentMillisecond
    // its Clip was it should recalc which sources to play as if we were going from
    // 0 to the the target millisecond because of the different way the Playback operates
    // (it has no onProgress). For this, it's very important to store the information
    // that it entered the transitional state so on the next playing state moveTo
    // to force as from ms 0.

    _this.transitioned = false;
    props.subscribe(helper.getAnId(), _this._stateChange.bind(_assertThisInitialized(_this)), 0, 1, true);
    return _this;
  }

  _createClass(AudioPlaybackChannel, [{
    key: "_stateChange",
    value: function _stateChange(ms, state) {
      if (state === "paused" || state === "idle" || state === "blocked") {
        this._stopPlayingIncidents();

        this.transitioned = true;
      }
    }
  }, {
    key: "_stopPlayingIncidents",
    value: function _stopPlayingIncidents() {
      for (var i = 0; i < this.playingIncidentsIds.length; i++) {
        var incidentInfo = this.playingIncidentsIds[i].split(dataSeparator);

        this._incidentById(incidentInfo[0]).stop(incidentInfo[1]);
      }

      this.playingIncidentsIds = [];
    }
    /**
     @param {int} from - the millisecond to start from
     @param {int} to - the millisecond to go to
     @param {string} contextId - the context id to move
     @param {boolean} forceReset - set to true when we want full flash
     */

  }, {
    key: "moveTo",
    value: function moveTo(from, to, contextId) {
      var forceReset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      if (this.runTimeInfo.state === 'transitional' || forceReset === true) {
        this.transitioned = true;

        this._stopPlayingIncidents();

        for (var i = 0; i < this.incidents.length; i++) {
          var laneItem = this.incidents[i];

          var incident = this._incidentById(laneItem.id);

          if (to < laneItem.millisecond) {
            incident.onProgress(0, 0, contextId, true);
          } else if (to > laneItem.millisecond + incident.duration) {
            incident.onProgress(1, incident.duration, contextId, true);
          } else {
            incident.onProgress((to - laneItem.millisecond) / incident.duration, to - laneItem.millisecond, contextId, true);
          }
        }

        return;
      } else {
        if (this.transitioned === true) {
          from = 0;
          this.transitioned = false;
        }
      }

      var that = this;

      var startingAnims = _filter(this.incidents, function (laneItem) {
        return laneItem.millisecond >= from && laneItem.millisecond < to && laneItem.millisecond + that._incidentById(laneItem.id).duration > to;
      });

      var finishingAnims = _filter(this.incidents, function (laneItem) {
        return that._incidentById(laneItem.id).duration + laneItem.millisecond > from && that._incidentById(laneItem.id).duration + laneItem.millisecond <= to; // or it ends after the target millisecond but also starts before it
      }); //console.log(this._incidentById);
      // console.log(from, to);
      // console.log(startingAnims);
      // console.log(finishingAnims);


      for (var _i = 0; _i < startingAnims.length; _i++) {
        var _laneItem = startingAnims[_i];

        var MediaIncident = this._incidentById(_laneItem.id); // onProgress(fraction, milliseconds, contextId, forceReset = false) {


        var overcameEnd = (to - _laneItem.millisecond) / MediaIncident.duration >= 1;
        var fraction = overcameEnd ? 1 : (to - _laneItem.millisecond) / MediaIncident.duration;
        var millisecond = overcameEnd ? MediaIncident.duration : to - _laneItem.millisecond;
        var startAttempt = MediaIncident.play(fraction, millisecond, contextId);

        if (startAttempt === true) {
          this.playingIncidentsIds.push("".concat(_laneItem.id).concat(dataSeparator).concat(contextId));
        }
      }

      for (var _i2 = 0; _i2 < finishingAnims.length; _i2++) {
        var _laneItem2 = finishingAnims[_i2];

        var _MediaIncident = this._incidentById(_laneItem2.id);

        _MediaIncident.stop(contextId);

        var index = this.playingIncidentsIds.indexOf("".concat(_laneItem2.id).concat(dataSeparator).concat(contextId));

        if (index > -1) {
          this.playingIncidentsIds.splice(index, 1);
        }
      }

      this.runTimeInfo.currentMillisecond = to;
    }
  }]);

  return AudioPlaybackChannel;
}(ClipsChannel);

module.exports = AudioPlaybackChannel;