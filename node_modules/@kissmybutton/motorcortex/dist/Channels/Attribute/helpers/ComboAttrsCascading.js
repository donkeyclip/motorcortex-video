"use strict";

/*
lane:
     * [
     *      {
     *          id: the id of the Incident
     *          millisecond: the millisecond of the channel this Animation (that affects the selector/attribute pair) runs
     *      }
     *  ]
*/
function updateFinalValues(affectedIncident, initialValues, originalFinalValues, finalValues) {
  // console.log(initialValues, originalFinalValues);
  var change = false;

  for (var key in initialValues) {
    if (!Object.prototype.hasOwnProperty.call(originalFinalValues, key)) {
      change = true;
      finalValues[key] = initialValues[key];
    }
  }

  affectedIncident.animatedAttributeValue = finalValues;
  return change;
}
/**
 * This function takes as input the index of the affected incident on the lane,
 * the lane and it re-calculates the
 * initial and final values of all the following incidents in the lane.
 * The function is used only in cases of combo attributes
 *
 * @param {boolean} store - if set to true the first Incident to be edited stores the
 *      initial values as its pureInitialValues
 **/


function setInitialValue(lane, incidentsById, newInitialValues, affectedIndex) {
  var store = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var affectedItem = lane[affectedIndex];

  var affectedIncident = incidentsById._get(affectedItem.id);

  affectedIncident.setInitialValue(newInitialValues, store);
  var change = updateFinalValues(affectedIncident, affectedIncident.initialValue, affectedIncident.originalAnimatedAttributeValue, JSON.parse(JSON.stringify(affectedIncident.animatedAttributeValue))); /// if the final values have changed according to the new initial values and there is
  // a following incident on the lane

  if (change) {
    affectedIncident.lastWish();
    affectedIncident.onGetContext();
  }

  if (change && affectedIndex < lane.length - 1) {
    setInitialValue(lane, incidentsById, affectedIncident.animatedAttributeValue, affectedIndex + 1, false);
  }
}

module.exports = setInitialValue;