"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Helper = require('../_coreUtils/Helper');

var helper = new Helper();

var Channel =
/*#__PURE__*/
function () {
  function Channel(props) {
    _classCallCheck(this, Channel);

    this.runTimeInfo = props.runTimeInfo;
    this.context = props.context;
    this.onInitialise();
    this.getIncidentById = props.getIncidentById; // this.type = "plain";
  }

  _createClass(Channel, [{
    key: "onInitialise",
    value: function onInitialise() {}
  }, {
    key: "_resize",
    value: function _resize() {
      helper.log('Please overwite the _resize method of the Channel');
    }
    /**
     * @param {array} incidents - A collection of Incidents in the form:
     * {
     *  millisecond
     *  incident
     *  id
     * }
     * @returns either:
     *   {
     *       result:true,
     *       execute: // an array of functions that when executed it will add the Incidents on the Channels
     *   }
     *   or
     *   {
     *       result: false,
     *       errors
     *   }
     */

  }, {
    key: "addIncidents",
    value: function addIncidents(incidents) {
      // first check the Incidents addition directly using the checkAddition method of the class
      var result = this.checkAddition(incidents);

      if (result.result === false) {
        return {
          result: false,
          errors: result.errors
        };
      } else {
        return {
          result: true,
          execute: result.execute
        };
      }
    }
    /**
     * It initially checks if the edit is allowed and if it is it retuns an array of executable functions
     * that apply the change
     * @param {array} incidents - the list of the incidents to edit in an array format [object, object, ...]
     * @param {int} millisecondsDelta - the milliseconds delta to apply to the incidents
     * @returns {object} -
     * either:
     {
        result: true,
        execute: // array of functions to be executed in order to apply the edit
     }
     or
     {
         result: false,
         errors: // an array including all the errors / conflicts found on edit
     }
    */

  }, {
    key: "editIncidents",
    value: function editIncidents(incidents, millisecondsDelta) {
      // first check the Incidents addition directly using the checkAddition method of the class
      var result = this.checkEdit(incidents, millisecondsDelta);

      if (result.result === false) {
        return {
          result: false,
          errors: result.errors
        };
      } else {
        return {
          result: true,
          execute: result.execute
        };
      }
    }
    /**
     * Method to remove incidents
     * @param {array} incidents - the ids of the incidents to remove in an array format
     * @param {object} props
     * @retuns {object} -
     * either:
     {
        result: true,
        execute: // array of functions to be executed in order to apply the edit
     }
     or
     {
         result: false,
         errors: // an array including all the errors / conflicts found on edit
     }
    */

  }, {
    key: "removeIncidents",
    value: function removeIncidents(incidents) {
      var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      // first check the Incidents addition directly using the checkAddition method of the class
      var result = this.checkDelete(incidents, props);

      if (result.result === false) {
        return {
          result: false,
          errors: result.errors
        };
      } else {
        return {
          result: true,
          execute: result.execute
        };
      }
    }
    /**
     * This method is invoked whenever a CASI (the owner of the Channel) enters
     * the tree of another clip, so the scratch values of all first Incidents of
     * each channel should be recalculated based on the context. All Channels
     * that extend Channel can rewrite this method accordingly
     * @param {string} contextId - The id of the context of the Clip Copy according to which
     *      we are going to recalc the scratch values
     **/

  }, {
    key: "recalcScratchValues",
    value: function recalcScratchValues(contextId) {}
    /**
     * On this method the user defines the specific rules that apply on the plugin itself and on the Incidents of the plugin itself
     * The method should either return {result: true} or {result: false, errors:[{error-object}]}, where error-object has the structure:
     *  {
            incident: // reference to the Incident object that has bee discarded
            error: // text
        }
    * @param {array} incidents - a colleciton of all incidents to be added on the form:
    *
        {
            id
            millisecond
            incident
        }
    * @returns {object} -
    * either:
        {
            result:true,
            execute: // a function that when executed it will add the Incidents on the Channels
        }
        or
        {
            result: false,
            errors
        }
    */

  }, {
    key: "checkAddition",
    value: function checkAddition(incidents) {
      // eslint-disable-line no-unused-vars
      return {
        result: true,
        execute: function execute() {}
      };
    }
  }, {
    key: "checkEdit",
    value: function checkEdit(incidentsArray, millisecondsDelta) {
      // eslint-disable-line no-unused-vars
      return {
        result: true,
        execute: function execute() {}
      };
    }
  }, {
    key: "checkDelete",
    value: function checkDelete(incidentIds) {
      // eslint-disable-line no-unused-vars
      return {
        result: true,
        execute: function execute() {}
      };
    }
  }, {
    key: "checkResizedIncidents",
    value: function checkResizedIncidents(incidents) {
      // eslint-disable-line no-unused-vars
      return {
        result: true,
        execute: function execute() {}
      };
    }
  }, {
    key: "moveTo",
    value: function moveTo(from, to, contextId) {} // eslint-disable-line no-unused-vars

  }], [{
    key: "type",
    get: function get() {
      return "plain";
    }
  }]);

  return Channel;
}();

module.exports = Channel;