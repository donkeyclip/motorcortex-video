"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Helper = require('../../_coreUtils/Helper');

var helper = new Helper();

var Channel = require('../Channel');

var _sortBy = require('../../../lodash-custom-build/modularize/lodash.sortby/index.js');

var _filter = require('../../../lodash-custom-build/modularize/lodash.filter/index.js');

var ClipChannel =
/*#__PURE__*/
function (_Channel) {
  _inherits(ClipChannel, _Channel);

  function ClipChannel() {
    _classCallCheck(this, ClipChannel);

    return _possibleConstructorReturn(this, _getPrototypeOf(ClipChannel).apply(this, arguments));
  }

  _createClass(ClipChannel, [{
    key: "onInitialise",

    /*
    this.incidents is a collection of {incident, id, millisecond} objects always kept in order
        from lower to higher millisecond
    this.incidetnsById is an index of the incidents kept by id (this.incidents[incident-id] = Incident)
    */
    value: function onInitialise() {
      this.incidents = [];
      this.incidentsById = {};
    }
  }, {
    key: "_incidentById",
    value: function _incidentById(id) {
      return this.incidentsById[id];
    }
  }, {
    key: "_resize",
    value: function _resize(durationFraction) {
      for (var i = 0; i < this.incidents.length; i++) {
        this.incidents[i].millisecond = this.incidents[i].millisecond * durationFraction;
      }
    }
    /**
    * @param {array} incidents - a colleciton of all incidents to be added on the form:
    *
        {
            id
            millisecond
            incident
        }
    * @returns {object} -
    * either:
        {
            result:true,
            execute: // a function that when executed it will add the Incidents on the Channels
        }
        or
        {
            result: false,
            errors
        }
    */

  }, {
    key: "checkAddition",
    value: function checkAddition(incidents) {
      var errors = [];
      var candidateIncidentsById = {};
      var incidentsToConcat = [];

      for (var i = 0; i < incidents.length; i++) {
        candidateIncidentsById[incidents[i].id] = incidents[i].incident;
        incidentsToConcat.push({
          id: incidents[i].id,
          millisecond: incidents[i].millisecond
        });

        if (Object.prototype.hasOwnProperty.call(this.incidentsById, incidents[i].id)) {
          helper.error("Incident with the id ".concat(incidents[i].id, " already exists. Addition is rejected."));
          errors.push({
            type: 'Already existing id',
            meta: {
              id: incidents[i].id
            }
          });
        }
      }

      if (errors.length > 0) {
        return {
          result: false,
          errors: errors
        };
      }

      var that = this;

      var exec = function exec() {
        that.incidentsById = Object.assign(that.incidentsById, candidateIncidentsById);
        that.incidents = that.incidents.concat(incidentsToConcat);
        that.incidents = _sortBy(that.incidents, [function (laneItem) {
          return laneItem.millisecond;
        }]);

        for (var _i = 0; _i < incidents.length; _i++) {
          that._incidentById(incidents[_i].id)._onGetContextOnce(that.context);
        }
      };

      return {
        result: true,
        execute: exec
      };
    }
    /**
    @param {array} incidentsArray - A collection of the Incidetns to get edited in the form:
    {
        id
        millisecond
        incident
    }
    @param {int} millisecondsDelta- the delta of the star point of the provided incidents
    */

  }, {
    key: "checkEdit",
    value: function checkEdit(incidentsArray, millisecondsDelta) {
      var that = this;

      var exec = function exec() {
        for (var i = 0; i < incidentsArray.length; i++) {
          for (var j = 0; j < that.incidents.length; j++) {
            if (that.incidents[j].id === incidentsArray[i].id) {
              that.incidents[j].millisecond += millisecondsDelta;
              break;
            }
          }
        }

        that.incidents = _sortBy(that.incidents, [function (laneItem) {
          return laneItem.millisecond;
        }]);
      };

      return {
        result: true,
        execute: exec
      };
    }
  }, {
    key: "checkDelete",
    value: function checkDelete(incidentsArray) {
      var that = this;
      var incidentIds = [];

      for (var i = 0; i < incidentsArray.length; i++) {
        incidentIds.push(incidentsArray[i].id);
      }

      var exec = function exec() {
        var newIncidents = _filter(that.incidents, function (incident) {
          return incidentIds.indexOf(incident.id) === -1;
        });

        that.incidents = newIncidents;

        for (var _i2 = 0; _i2 < incidentIds.length; _i2++) {
          delete that.incidentsById[incidentIds[_i2]];
        }
      };

      return {
        result: true,
        execute: exec
      };
    }
    /**
     * @param {array} incidents - [{id, start, end, startDelta}]
     */

  }, {
    key: "checkResizedIncidents",
    value: function checkResizedIncidents(incidents) {
      var that = this;

      var exec = function exec() {
        for (var i = 0; i < incidents.length; i++) {
          for (var j = 0; j < that.incidents.length; j++) {
            if (that.incidents[j].id === incidents[i].id) {
              that.incidents[j].millisecond += incidents[i].startDelta;
              break;
            }
          }
        }

        that.incidents = _sortBy(that.incidents, [function (laneItem) {
          return laneItem.millisecond;
        }]);
      };

      return {
        result: true,
        execute: exec
      };
    }
    /**
     @param {int} from - the millisecond to start from
     @param {int} to - the millisecond to go to
     @param {string} contextId - the context id to move
     @param {boolean} forceReset - set to true when we want full flash
     */

  }, {
    key: "moveTo",
    value: function moveTo(from, to, contextId) {
      var forceReset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      if (forceReset === true) {
        // incidents: [{id, millisecond}, {}, {}...]
        for (var i = 0; i < this.incidents.length; i++) {
          var laneItem = this.incidents[i];

          var incident = this._incidentById(laneItem.id);

          if (to < laneItem.millisecond) {
            incident.onProgress(0, 0, contextId, true);
          } else if (to > laneItem.millisecond + incident.duration) {
            incident.onProgress(1, incident.duration, contextId, true);
          } else {
            incident.onProgress((to - laneItem.millisecond) / incident.duration, to - laneItem.millisecond, contextId, true);
          }
        }
      } else {
        var that = this;
        var participatingItems;

        if (to > from) {
          participatingItems = _filter(this.incidents, function (laneItem) {
            return laneItem.millisecond + that._incidentById(laneItem.id).duration >= from && laneItem.millisecond + that._incidentById(laneItem.id).duration <= to || // it ends after from and before to millisecond
            that._incidentById(laneItem.id).duration + laneItem.millisecond >= to && laneItem.millisecond <= to; // or it ends after the target millisecond but also starts before it
          });
        } else {
          participatingItems = _filter(this.incidents, function (laneItem) {
            return laneItem.millisecond + that._incidentById(laneItem.id).duration >= to && laneItem.millisecond + that._incidentById(laneItem.id).duration <= from || // it ends after from and before to millisecond
            that._incidentById(laneItem.id).duration + laneItem.millisecond >= from && laneItem.millisecond <= from; // or it ends after the target millisecond but also starts before it
          });
        }

        for (var _i3 = 0; _i3 < participatingItems.length; _i3++) {
          var _laneItem = participatingItems[_i3];

          var contextAwareClipIncident = this._incidentById(_laneItem.id); // onProgress(fraction, milliseconds, contextId, forceReset = false) {


          var overcameEnd = (to - _laneItem.millisecond) / contextAwareClipIncident.duration >= 1;
          var fraction = overcameEnd ? 1 : (to - _laneItem.millisecond) / contextAwareClipIncident.duration;
          var millisecond = overcameEnd ? contextAwareClipIncident.duration : to - _laneItem.millisecond;
          contextAwareClipIncident.onProgress(fraction, millisecond, contextId, false);
        }
      } // this.runTimeInfo.currentMillisecond = to;

    }
  }]);

  return ClipChannel;
}(Channel);

module.exports = ClipChannel;