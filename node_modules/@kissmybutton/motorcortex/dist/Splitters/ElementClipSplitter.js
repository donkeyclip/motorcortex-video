"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var DWI = require('./ElementSplitter');

var ContextAwareClipIncident = require('./ContextAwareClipIncident');

var Channel = require('../Channels/Clip/ClipsChannel');
/**
 * This Class acts as the DOM Aware Incident for Clips. When constructed the Incident passed to
 * it is a Clip with FragmentHTML context handler.
 * On addition, edit or deletion of Incidents on the Fragmented Clip's tree, of the
 * Descriptive Clip this ElementClipSplitter implements, all updates on lanes
 * and everything that these clips need in order to run are made directly to the
 * ContextAwareIncidents of the DescriptiveClip's real Clip.
 */


var ElementClipSplitter =
/*#__PURE__*/
function (_DWI) {
  _inherits(ElementClipSplitter, _DWI);

  function ElementClipSplitter(descriptiveIncident, contextData) {
    var _this;

    _classCallCheck(this, ElementClipSplitter);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ElementClipSplitter).call(this, descriptiveIncident, contextData));
    _this.realClip = descriptiveIncident.realClip;
    return _this;
  }

  _createClass(ElementClipSplitter, [{
    key: "_createElementIncident",
    value: function _createElementIncident(element, descriptiveIncident, contextData, elementIndex, totalElements, mcid) {
      var constructionArguments = descriptiveIncident.realClip.exportConstructionArguments();
      var constructionIngredients = {
        incidentId: descriptiveIncident.id,
        attrs: constructionArguments.attrs,
        props: _objectSpread({}, constructionArguments.props, {
          selector: contextData.context.getElementSelectorByMCID(mcid),
          runTimeInfo: descriptiveIncident.runTimeInfo
        }),
        Incident: descriptiveIncident.constructor.Incident,
        plugin_npm_name: descriptiveIncident.constructor.plugin_npm_name,
        Channel: Channel,
        DescriptiveIncident: descriptiveIncident
      };
      var contextAwareClipIncident = new ContextAwareClipIncident(constructionIngredients, contextData, mcid, descriptiveIncident);
      this.addChild(contextAwareClipIncident, 0);
    }
  }, {
    key: "duration",
    get: function get() {
      return _get(_getPrototypeOf(ElementClipSplitter.prototype), "duration", this);
    }
    /*
    ElementClipSplitter split the DescriptiveClip to element ContextAwareIncidents
    All of the element ContextAwareClipIncidents instantiated share the same
    DescriptiveClip and thus the same realClip. So ElementClipSplitter are
    the Node from where a realClip starts to get copies.
    Resizing though means resizing the realClip. In order to avoid redunduncy we
    manage the resize here and we don't pass further down to the ContextAwareClipIncidents
    the resizing command.
    */
    ,
    set: function set(milliseconds) {
      this.realClip._resize(milliseconds / this.realClip.duration);

      this._duration = milliseconds;
    }
  }]);

  return ElementClipSplitter;
}(DWI);

module.exports = ElementClipSplitter;