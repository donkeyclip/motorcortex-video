"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }

function _getDecoratorsApi() { _getDecoratorsApi = function _getDecoratorsApi() { return api; }; var api = { elementsDefinitionOrder: [["method"], ["field"]], initializeInstanceElements: function initializeInstanceElements(O, elements) { ["method", "field"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === "own") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function initializeClassElements(F, elements) { var proto = F.prototype; ["method", "field"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === "static" || placement === "prototype")) { var receiver = placement === "static" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function defineClassElement(receiver, element) { var descriptor = element.descriptor; if (element.kind === "field") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function decorateClass(elements, decorators) { var newElements = []; var finishers = []; var placements = { "static": [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function addElementPlacement(element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError("Duplicated element (" + element.key + ")"); } keys.push(element.key); }, decorateElement: function decorateElement(element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function decorateConstructor(elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError("Duplicated element (" + elements[j].key + ")"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function fromElementDescriptor(element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: "Descriptor", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === "field") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function toElementDescriptors(elementObjects) { if (elementObjects === undefined) return; return _toArray(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, "finisher", "An element descriptor"); this.disallowProperty(elementObject, "extras", "An element descriptor"); return element; }, this); }, toElementDescriptor: function toElementDescriptor(elementObject) { var kind = String(elementObject.kind); if (kind !== "method" && kind !== "field") { throw new TypeError('An element descriptor\'s .kind property must be either "method" or' + ' "field", but a decorator created an element descriptor with' + ' .kind "' + kind + '"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== "static" && placement !== "prototype" && placement !== "own") { throw new TypeError('An element descriptor\'s .placement property must be one of "static",' + ' "prototype" or "own", but a decorator created an element descriptor' + ' with .placement "' + placement + '"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, "elements", "An element descriptor"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== "field") { this.disallowProperty(elementObject, "initializer", "A method descriptor"); } else { this.disallowProperty(descriptor, "get", "The property descriptor of a field descriptor"); this.disallowProperty(descriptor, "set", "The property descriptor of a field descriptor"); this.disallowProperty(descriptor, "value", "The property descriptor of a field descriptor"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function toElementFinisherExtras(elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, "finisher"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function fromClassDescriptor(elements) { var obj = { kind: "class", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: "Descriptor", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function toClassDescriptor(obj) { var kind = String(obj.kind); if (kind !== "class") { throw new TypeError('A class descriptor\'s .kind property must be "class", but a decorator' + ' created a class descriptor with .kind "' + kind + '"'); } this.disallowProperty(obj, "key", "A class descriptor"); this.disallowProperty(obj, "placement", "A class descriptor"); this.disallowProperty(obj, "descriptor", "A class descriptor"); this.disallowProperty(obj, "initializer", "A class descriptor"); this.disallowProperty(obj, "extras", "A class descriptor"); var finisher = _optionalCallableProperty(obj, "finisher"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function runClassFinishers(constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== "function") { throw new TypeError("Finishers must return a constructor."); } constructor = newConstructor; } } return constructor; }, disallowProperty: function disallowProperty(obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + " can't have a ." + name + " property."); } } }; return api; }

function _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === "method") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === "get") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === "set") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === "field") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === "field" ? "field" : "method", key: key, placement: def["static"] ? "static" : def.kind === "field" ? "own" : "prototype", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === "field") element.initializer = def.value; return element; }

function _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }

function _coalesceClassElements(elements) { var newElements = []; var isSameElement = function isSameElement(other) { return other.kind === "method" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === "method" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError("Duplicated methods (" + element.key + ") can't be decorated."); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError("Decorators can't be placed on different accessors with for " + "the same property (" + element.key + ")."); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }

function _hasDecorators(element) { return element.decorators && element.decorators.length; }

function _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }

function _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== "function") { throw new TypeError("Expected '" + name + "' to be a function"); } return value; }

function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }

function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function set(target, property, value, receiver) { if (typeof Reflect !== "undefined" && Reflect.set) { set = Reflect.set; } else { set = function set(target, property, value, receiver) { var base = _superPropBase(target, property); var desc; if (base) { desc = Object.getOwnPropertyDescriptor(base, property); if (desc.set) { desc.set.call(receiver, value); return true; } else if (!desc.writable) { return false; } } desc = Object.getOwnPropertyDescriptor(receiver, property); if (desc) { if (!desc.writable) { return false; } desc.value = value; Object.defineProperty(receiver, property, desc); } else { _defineProperty(receiver, property, value); } return true; }; } return set(target, property, value, receiver); }

function _set(target, property, value, receiver, isStrict) { var s = set(target, property, value, receiver || target); if (!s && isStrict) { throw new Error('failed to set property'); } return value; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var Leaf = require('../Tree/Leaf');

var incidentFromIngredients = require('../IncidentFromDefinition/incidentFromIngredients');

var getIncidentsByChannel = require('../_decorators/getIncidentsByChannel');

var _CONST = require('../_configuration/_CONST');

var easings = require('../_coreUtils/easings');

var ContextAwareIncident = _decorate(null, function (_initialize, _Leaf) {
  var ContextAwareIncident =
  /*#__PURE__*/
  function (_Leaf2) {
    _inherits(ContextAwareIncident, _Leaf2);

    function ContextAwareIncident(constructionIngredients, contextData, mcid, attribute) {
      var _this;

      _classCallCheck(this, ContextAwareIncident);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ContextAwareIncident).call(this, _objectSpread({}, constructionIngredients.props, {
        id: attribute !== null ? "".concat(constructionIngredients.incidentId, "_").concat(mcid, "_").concat(attribute) : "".concat(constructionIngredients.incidentId, "_").concat(mcid)
      }))); // a property to hold all of the contexts

      _initialize(_assertThisInitialized(_this));

      _this.contexts = {};
      _this.constructionIngredients = constructionIngredients;
      _this.mcid = mcid;
      _this.attribute = attribute; // this._duration = constructionIngredients.props.duration;

      _this.mc_plugin_npm_name = constructionIngredients.plugin_npm_name;
      _this.plugin_channel_class = constructionIngredients.Channel;
      _this.DescriptiveIncident = constructionIngredients.DescriptiveIncident;

      _this.addContext(contextData);

      if (attribute !== null) {
        if (_typeof(_this.constructionIngredients.attrs.animatedAttrs[_this.attribute]) === 'object') {
          _this.originalAnimatedAttributeValue = Object.assign({}, _this.constructionIngredients.attrs.animatedAttrs[_this.attribute]);
        } else {
          _this.originalAnimatedAttributeValue = _this.constructionIngredients.attrs.animatedAttrs[_this.attribute];
        }
      }

      _this.easing = _this.props.easing || 'linear';
      return _this;
    }

    return ContextAwareIncident;
  }(_Leaf);

  return {
    F: ContextAwareIncident,
    d: [{
      kind: "get",
      key: "originalContext",
      value: function originalContext() {
        return this.contexts[this.originalContextKey];
      }
    }, {
      kind: "get",
      key: "duration",
      value: function duration() {
        return _get(_getPrototypeOf(ContextAwareIncident.prototype), "duration", this);
      }
    }, {
      kind: "set",
      key: "duration",
      value: function duration(milliseconds) {
        _set(_getPrototypeOf(ContextAwareIncident.prototype), "duration", milliseconds, this, true);

        for (var context in this.contexts) {
          this.contexts[context].duration = milliseconds;
        }
      }
    }, {
      kind: "method",
      key: "addContext",
      value: function addContext(contextData) {
        var forceGetContext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        // if it's the first context to be added then it's the original
        var isTheOriginalContext = false;

        if (Object.keys(this.contexts).length === 0) {
          this.originalContextKey = contextData.clipId;
          this.originalClipContext = contextData.context;
          isTheOriginalContext = true;
        }

        var ingredientsToPass = _objectSpread({}, this.constructionIngredients, {
          context: contextData.context,
          mcid: this.mcid
        });

        var whatToAdd = incidentFromIngredients(ingredientsToPass);
        this.contexts[contextData.clipId] = whatToAdd; // when we add a new context we must set the inital value of the newly added Incidents
        // but only for Incidents with animatedAttrs

        if (!isTheOriginalContext && this.attribute !== null) {
          this.contexts[contextData.clipId].setInitialValue(this.getInitialValue());
        }

        if (forceGetContext === true) {
          this.contexts[contextData.clipId]._onGetContextOnce();
        }
      }
    }, {
      kind: "method",
      key: "handleAddContext",
      value: function handleAddContext(target, payload) {
        this.addContext(payload, true);
        return true;
      }
    }, {
      kind: "method",
      decorators: [getIncidentsByChannel],
      key: "getIncidentsByChannel",
      value: function getIncidentsByChannel() {}
    }, {
      kind: "method",
      key: "onProgress",
      value: function onProgress(fraction, milliseconds, contextId) {
        /* MonoIncidents are totally agnostic about delay, hiatus and repeats.
        CAI is not that's exactly the point where these properties management occurs.
        Having alredy set the duration of the ContextAwareIncident according to
        all of these props, here the CAI decides on the progress that its MonoIncidents
        are to on at the given millisecond and according to the given props.
        */
        // step 1: find the full delay-duration-hiatus duration of one repeat
        var repeatDuration = this.delay + this.props.duration + this.hiatus; // step 2.a: find the running repeat and millisecond of this repeat

        var millisecondWithinRepeat = milliseconds % repeatDuration; // step 2.b: decide between 0 and 1

        if (milliseconds !== 0 && millisecondWithinRepeat === 0) {
          millisecondWithinRepeat = this.delay + this.props.duration;
        } // step 3: find the millisecond of the MonoIncident


        var MI_millisecond = millisecondWithinRepeat - this.delay;

        if (MI_millisecond < 0) {
          MI_millisecond = 0;
        } else if (MI_millisecond > this.props.duration) {
          // if it has stepped into hiatus
          MI_millisecond = this.props.duration;
        }

        var MI_fraction = MI_millisecond / this.props.duration;
        var eased_MI_fraction = easings[this.easing](MI_fraction);
        var eased_MI_millisecond = eased_MI_fraction * this.props.duration;

        if (contextId === undefined) {
          for (var context in this.contexts) {
            this.contexts[context].onProgress(eased_MI_fraction, eased_MI_millisecond);
          }

          return;
        }

        this.contexts[contextId].onProgress(eased_MI_fraction, eased_MI_millisecond);
      }
      /** METHODS THAT ACT AS "PROXY" TO ALL OF THE INCIDENTS BELONGING TO
       * THE INCIDENTS COLLECTION OF THE CONTEXT AWARE INCIDENT
       **/

    }, {
      kind: "get",
      key: "animatedAttributeValue",
      value: function animatedAttributeValue() {
        return this.constructionIngredients.attrs.animatedAttrs[this.attribute];
      }
    }, {
      kind: "set",
      key: "animatedAttributeValue",
      value: function animatedAttributeValue(value) {
        this.constructionIngredients.attrs.animatedAttrs[this.attribute] = value;
      } // massive editing methods that apply the request massively to all of the
      // Incidents of all of the contexts

    }, {
      kind: "method",
      key: "gotContext",
      value: function gotContext() {
        for (var context in this.contexts) {
          this.contexts[context].gotContext();
        }
      }
    }, {
      kind: "method",
      key: "_onGetContextOnce",
      value: function _onGetContextOnce() {
        for (var context in this.contexts) {
          this.contexts[context]._onGetContextOnce();
        }
      }
    }, {
      kind: "method",
      key: "lastWish",
      value: function lastWish() {
        for (var context in this.contexts) {
          this.contexts[context].lastWish();
        }
      }
    }, {
      kind: "method",
      key: "onGetContext",
      value: function onGetContext() {
        for (var context in this.contexts) {
          this.contexts[context].onGetContext();
        }
      }
    }, {
      kind: "method",
      key: "getInitialValue",
      value: function getInitialValue() {
        var attribute = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        if (attribute === null) {
          attribute = this.attribute;
        }

        return this.originalContext.getInitialValue();
      }
    }, {
      kind: "get",
      key: "initialValue",
      value: function initialValue() {
        return this.getInitialValue();
      }
    }, {
      kind: "get",
      key: "scratchValue",
      value: function scratchValue() {
        return this.originalContext.scratchValue;
      }
    }, {
      kind: "get",
      key: "pureInitialValues",
      value: function pureInitialValues() {
        return this.originalContext.pureInitialValues;
      }
    }, {
      kind: "method",
      key: "setInitialValue",
      value: function setInitialValue() {
        var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var store = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        if (value === null) {
          value = this.getScratchValue();
        }

        for (var context in this.contexts) {
          this.contexts[context].setInitialValue(JSON.parse(JSON.stringify(value)), store);
        }
      }
    }, {
      kind: "method",
      key: "getScratchValue",
      value: function getScratchValue() {
        var contextId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        if (contextId === null) {
          var contextsKeys = Object.keys(this.contexts);

          if (Object.prototype.hasOwnProperty.call(this.originalClipContext, 'nonFragmentedContext')) {
            var ingredientsToPass = _objectSpread({}, this.constructionIngredients, {
              context: this.originalClipContext.nonFragmentedContext,
              mcid: this.mcid
            });

            var tempIncident = incidentFromIngredients(ingredientsToPass);
            return tempIncident.getScratchValue();
          } else if (contextsKeys.length === 1) {
            return this.originalContext.getScratchValue();
          } else {
            // prefer another (not the original) context to provide scratch values
            return this.contexts[contextsKeys[1]].getScratchValue();
          }
        }

        return this.contexts[contextId].getScratchValue();
      }
    }, {
      kind: "method",
      key: "setCompoAttrKeyValue",
      value: function setCompoAttrKeyValue(key, value) {
        for (var context in this.contexts) {
          this.contexts[context].attrs.animatedAttrs[this.attribute][key] = value;
          this.contexts[context].lastWish();
          this.contexts[context].onGetContext();
        }
      }
    }, {
      kind: "method",
      key: "play",
      value: function play(fraction, ms, contextId) {
        return this.contexts[contextId].play(ms);
      }
    }, {
      kind: "method",
      key: "stop",
      value: function stop(contextId) {
        this.contexts[contextId].stop();
      }
    }]
  };
}, Leaf);

module.exports = ContextAwareIncident;