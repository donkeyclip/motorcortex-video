"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var Validator = require("fastest-validator");

var DescriptiveIncident = require('./DescriptiveIncidents/DescriptiveIncident');

var DescriptiveGroup = require('./DescriptiveIncidents/DescriptiveGroup');

var DescriptiveClip = require('./DescriptiveIncidents/DescriptiveClip');

var DescriptiveAudioClip = require('./DescriptiveIncidents/DescriptiveAudioClip');

var MonoIncident = require('./BaseClasses/MonoIncident');

var MediaPlayback = require('./BaseClasses/MediaPlayIncident');

var AudioPlaybackChannel = require('./Channels/Media/AudioPlaybackChannel');

var ExtendableClip = require('./Clip/ExtendableClip');

var DOMClip = require('./Clip/DOMClip');

var AttributeChannel = require('./Channels/Attribute/AttributeChannel');

var TimeCapsule = require('./_coreUtils/TimeCapsule');

var Helper = require('./_coreUtils/Helper');

var helper = new Helper({
  logLevel: 0
});

var checkPlugin = function checkPlugin(main) {
  if (Object.prototype.hasOwnProperty.call(main, "default")) {
    main = main["default"];
  }

  var plugin_name = main.npm_name;
  var check = true;

  if (!Object.prototype.hasOwnProperty.call(main, "name")) {
    helper.error("Warning on plugin ".concat(plugin_name, ". A plugin is always good to have its name on\n        its main.js file, under the key \"name\". It's missing from this plugin"));
  }

  if (!Object.prototype.hasOwnProperty.call(main, "incidents") && !Object.prototype.hasOwnProperty.call(main, "Clip")) {
    helper.error("Error on plugin ".concat(plugin_name, ". A plugin must expose at least one Incident or a Clip.\n        Exposed plugin Incidents should be defined on the \"incidents\" key of the main.js file while Clips on the \"Clip\"."));
    check = false;
  }

  if (Object.prototype.hasOwnProperty.call(main, "incidents") && !helper.isArray(main.incidents)) {
    helper.error("Error on plugin ".concat(plugin_name, ". thePlugin exposed Incidents are defined on the \"incidents\" key of the main.js file in array format.\n        Please refer to the documentation"));
    check = false;
  } else if (Object.prototype.hasOwnProperty.call(main, "incidents")) {
    for (var i = 0; i < main.incidents.length; i++) {
      var exposedIncidentDefinition = main.incidents[i];

      if (_typeof(exposedIncidentDefinition.exportable) === "object") {
        if (Object.prototype.hasOwnProperty.call(exposedIncidentDefinition.exportable, "default")) {
          exposedIncidentDefinition.exportable = exposedIncidentDefinition.exportable["default"];
        }
      }

      if (!(exposedIncidentDefinition.exportable.prototype instanceof DescriptiveGroup) && !(exposedIncidentDefinition.exportable.prototype instanceof DescriptiveClip) && !(exposedIncidentDefinition.exportable.prototype instanceof MonoIncident) && !(exposedIncidentDefinition.exportable.prototype instanceof MediaPlayback)) {
        helper.error("Error on plugin ".concat(plugin_name, ". Exportable Incidents by any plugin must extend one of the base classes provided by MotorCortex.\n                ").concat(exposedIncidentDefinition.exportable.constructor.name, " doesn't.\n                Please refer to documentation"));
        check = false;
      }

      if (!Object.prototype.hasOwnProperty.call(exposedIncidentDefinition, "name")) {
        helper.error("Error on plugin ".concat(plugin_name, ". Exportable Incidents by any plugin must have the \"name\" key which defines the name of the exported Incident.\n                Please refer to documentation"));
        check = false;
      }

      if (!Object.prototype.hasOwnProperty.call(exposedIncidentDefinition, "propTypes")) {
        helper.log("Warning on plugin ".concat(plugin_name, ".\n                It's always good for plugins to define the supported propTypes of their exposed Incidents' supported properties.\n                ").concat(exposedIncidentDefinition.exportable.constructor.name, " doesn't.\n                Please refer to documentation"), 'warning');
      }
    }
  }

  return check;
}; // plugin_name is the unique name of the plugin


function loadPlugin(plugin) {
  if (Object.prototype.hasOwnProperty.call(plugin, "default")) {
    plugin = plugin["default"];
  }

  if (!Object.prototype.hasOwnProperty.call(plugin, "npm_name")) {
    plugin.npm_name = "plugin_".concat(new Date().getTime());
  }

  if (!checkPlugin(plugin)) {
    return false;
  } else {
    // thePlugin is the plugin object which will hold on its keys
    // the names of the exposed Incidents of its. The keys of this object
    // are going to be identical with the names of the classes exposed
    var thePlugin = {};

    if (Object.prototype.hasOwnProperty.call(plugin, "Clip")) {
      var _class, _temp;

      var DynamicDescriptiveClip = (_temp = _class =
      /*#__PURE__*/
      function (_DescriptiveClip) {
        _inherits(DynamicDescriptiveClip, _DescriptiveClip);

        function DynamicDescriptiveClip() {
          _classCallCheck(this, DynamicDescriptiveClip);

          return _possibleConstructorReturn(this, _getPrototypeOf(DynamicDescriptiveClip).apply(this, arguments));
        }

        return DynamicDescriptiveClip;
      }(DescriptiveClip), _defineProperty(_class, "Incident", plugin.Clip), _defineProperty(_class, "audio", plugin.audio ? plugin.audio : "off"), _defineProperty(_class, "customClip", true), _temp);
      thePlugin.Clip = DynamicDescriptiveClip;
    } // if the plugin definition has compositeAttributes then we dynamically
    // create a new Channel class extending AttributeChannel setting the
    // composite Attributes on the fly. We can then use this Channel class
    // for all Incidents exposed by the plugin


    var AttributeChannelToUse = AttributeChannel;

    if (Object.prototype.hasOwnProperty.call(plugin, "compositeAttributes")) {
      AttributeChannelToUse =
      /*#__PURE__*/
      function (_AttributeChannel) {
        _inherits(AttributeChannelToUse, _AttributeChannel);

        function AttributeChannelToUse(props) {
          _classCallCheck(this, AttributeChannelToUse);

          props.comboAttributes = plugin.compositeAttributes;
          return _possibleConstructorReturn(this, _getPrototypeOf(AttributeChannelToUse).call(this, props));
        }

        return AttributeChannelToUse;
      }(AttributeChannel);
    } // for each of the exposed Incidents


    if (Object.prototype.hasOwnProperty.call(plugin, "incidents")) {
      var _loop = function _loop(i) {
        var incidentClass = plugin.incidents[i].exportable;
        var DynamicDescriptiveIncident = void 0; // the exportable Incident can be either a Clip, a Compo or an Incident
        // if it is an Incident

        if (incidentClass.prototype instanceof MonoIncident) {
          var _class2, _temp2;

          DynamicDescriptiveIncident = (_temp2 = _class2 =
          /*#__PURE__*/
          function (_DescriptiveIncident) {
            _inherits(DynamicDescriptiveIncident, _DescriptiveIncident);

            function DynamicDescriptiveIncident() {
              _classCallCheck(this, DynamicDescriptiveIncident);

              return _possibleConstructorReturn(this, _getPrototypeOf(DynamicDescriptiveIncident).apply(this, arguments));
            }

            return DynamicDescriptiveIncident;
          }(DescriptiveIncident), _defineProperty(_class2, "Incident", incidentClass), _defineProperty(_class2, "plugin_npm_name", plugin.npm_name), _defineProperty(_class2, "plugin", plugin.name), _defineProperty(_class2, "ClassName", plugin.incidents[i].name), _defineProperty(_class2, "Channel", AttributeChannelToUse), _defineProperty(_class2, "audio", plugin.audio ? plugin.audio : "off"), _temp2);
        } // if it is an Incident
        else if (incidentClass.prototype instanceof MediaPlayback) {
            var _class3, _temp3;

            DynamicDescriptiveIncident = (_temp3 = _class3 =
            /*#__PURE__*/
            function (_DescriptiveIncident2) {
              _inherits(DynamicDescriptiveIncident, _DescriptiveIncident2);

              function DynamicDescriptiveIncident() {
                _classCallCheck(this, DynamicDescriptiveIncident);

                return _possibleConstructorReturn(this, _getPrototypeOf(DynamicDescriptiveIncident).apply(this, arguments));
              }

              return DynamicDescriptiveIncident;
            }(DescriptiveIncident), _defineProperty(_class3, "Incident", incidentClass), _defineProperty(_class3, "plugin_npm_name", '@kissmybutton/media-playback'), _defineProperty(_class3, "plugin", plugin.name), _defineProperty(_class3, "ClassName", plugin.incidents[i].name), _defineProperty(_class3, "Channel", AudioPlaybackChannel), _defineProperty(_class3, "audio", plugin.audio ? plugin.audio : "off"), _temp3);
          } // else if it is a Clip
          else if (incidentClass.prototype instanceof DescriptiveClip) {
              var _class4, _temp4;

              DynamicDescriptiveIncident = (_temp4 = _class4 =
              /*#__PURE__*/
              function (_incidentClass) {
                _inherits(DynamicDescriptiveIncident, _incidentClass);

                function DynamicDescriptiveIncident() {
                  _classCallCheck(this, DynamicDescriptiveIncident);

                  return _possibleConstructorReturn(this, _getPrototypeOf(DynamicDescriptiveIncident).apply(this, arguments));
                }

                return DynamicDescriptiveIncident;
              }(incidentClass), _defineProperty(_class4, "plugin", plugin.name), _defineProperty(_class4, "ClassName", plugin.incidents[i].name), _defineProperty(_class4, "audio", plugin.audio ? plugin.audio : "on"), _temp4);
            } else if (incidentClass.prototype instanceof DescriptiveGroup) {
              var _class5, _temp5;

              DynamicDescriptiveIncident = (_temp5 = _class5 =
              /*#__PURE__*/
              function (_incidentClass2) {
                _inherits(DynamicDescriptiveIncident, _incidentClass2);

                function DynamicDescriptiveIncident() {
                  _classCallCheck(this, DynamicDescriptiveIncident);

                  return _possibleConstructorReturn(this, _getPrototypeOf(DynamicDescriptiveIncident).apply(this, arguments));
                }

                return DynamicDescriptiveIncident;
              }(incidentClass), _defineProperty(_class5, "plugin", plugin.name), _defineProperty(_class5, "ClassName", plugin.incidents[i].name), _temp5);
            }

        Object.defineProperty(thePlugin, plugin.incidents[i].name, {
          get: function get() {
            // the getter will construct a wrapper class which on the constructor will instantiate an object of the
            // exposed class, set to it the plugin name and channel class parameters and return
            // it from the constructor
            var WrapperClass = function WrapperClass(attrs, props) {
              _classCallCheck(this, WrapperClass);

              var instantiatedIncident = new DynamicDescriptiveIncident(attrs, props);

              if (Object.prototype.hasOwnProperty.call(plugin.incidents[i], "attributesValidationRules")) {
                var v = new Validator();
                var validationResult = v.validate(attrs, plugin.incidents[i].attributesValidationRules);

                if (validationResult.length > 0) {
                  var errorMessage = "Error on plugin's \"".concat(plugin.npm_name, "\" \"").concat(plugin.incidents[i].name, "\" instantiation. Errors:");

                  for (var _i = 0; _i < validationResult.length; _i++) {
                    errorMessage += "\n - ".concat(validationResult[_i].message, ". ").concat(validationResult[_i].actual, " provided");
                  }

                  console.error(errorMessage);
                  return {
                    result: false,
                    errors: validationResult
                  };
                }
              } else {
                helper.warning("It's always good to provide attributesValidationRules to the exported incidents. ".concat(plugin.npm_name, ".").concat(instantiatedIncident.constructor.name, " doesn't provide it"));
              }

              return instantiatedIncident;
            };

            return WrapperClass;
          }
        });
      };

      for (var i = 0; i < plugin.incidents.length; i++) {
        _loop(i);
      }
    }

    return thePlugin;
  }
}

var audioPluginMain = require('./Audio/main');

var AudioPlugin = loadPlugin(audioPluginMain);
module.exports = {
  API: {
    MonoIncident: MonoIncident,
    Group: DescriptiveGroup,
    Clip: DescriptiveClip,
    AudioClip: DescriptiveAudioClip,
    MediaPlayback: MediaPlayback,
    ExtendableClip: ExtendableClip,
    DOMClip: DOMClip
  },
  Group: DescriptiveGroup,
  Clip: DescriptiveClip,
  loadPlugin: loadPlugin,
  AudioClip: AudioPlugin.Clip,
  AudioPlayback: AudioPlugin.AudioPlayback,
  AudioEffect: AudioPlugin.AudioEffect,
  TimeCapsule: TimeCapsule
};