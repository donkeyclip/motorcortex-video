"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Helper = require('../../_coreUtils/Helper');

var helper = new Helper();

var ContextHandler = require('./ContextHandler');

var HTMLFragmentContextHandler =
/*#__PURE__*/
function (_ContextHandler) {
  _inherits(HTMLFragmentContextHandler, _ContextHandler);

  /**
   * @param {object} props - an object that should contain all of the following keys:
   * - html (the html template to render)
   * - css (the css template of the isolated tree)
   * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)
   * - host (an Element object that will host the isolated tree)
   * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)
   */
  function HTMLFragmentContextHandler() {
    var _this;

    var originalProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, HTMLFragmentContextHandler);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(HTMLFragmentContextHandler).call(this));
    var props = Object.assign({}, originalProps);

    if (!helper.isObject(props)) {
      helper.error("HTMLFragmentContextHandler expects an object on its constructor. ".concat(_typeof(props), " passed"));
      return _possibleConstructorReturn(_this, false);
    }

    if (!Object.prototype.hasOwnProperty.call(props, "html")) {
      props.html = '';
    }

    _this.isDOM = true;
    var fragment = document.createDocumentFragment();
    var wrapper = document.createElement('div');

    if (Object.prototype.hasOwnProperty.call(props, "containerParams")) {
      if (Object.prototype.hasOwnProperty.call(props, "width")) {
        wrapper.style.width = props.containerParams.width;
      }

      if (Object.prototype.hasOwnProperty.call(props, "height")) {
        wrapper.style.height = props.containerParams.height;
      }
    }

    wrapper.innerHTML = helper.renderTemplate(props.html, {
      params: props.initParams
    });
    fragment.appendChild(wrapper);
    wrapper.style.overflow = "hidden";
    _this.rootElement = wrapper;
    /* TODO make the context definition more generic so always the setCustomEntity gets set
    along with the rest of the required methods, so it can be used on the afterRender method
    of the DOMClip.
    The Clip will expose a method "setCustomEntity" that will set custom entities.
    TEST
    */

    _this.context = {
      document: document,
      window: window,
      clipContainer: _this.rootElement,
      rootElement: wrapper,
      unmount: function unmount() {
        props.host.removeChild(fragment);
      },
      getElements: _this.getElements.bind(_assertThisInitialized(_this)),
      getMCID: _this.getMCID.bind(_assertThisInitialized(_this)),
      setMCID: _this.setMCID.bind(_assertThisInitialized(_this)),
      getElementSelectorByMCID: _this.getElementSelectorByMCID.bind(_assertThisInitialized(_this)),
      getElementByMCID: _this.getElementByMCID.bind(_assertThisInitialized(_this)),
      setCustomEntity: _this.setCustomEntity.bind(_assertThisInitialized(_this)),
      fragment: true
    };
    _this.elementsByMCID = {};
    return _this;
  }

  return HTMLFragmentContextHandler;
}(ContextHandler);

module.exports = HTMLFragmentContextHandler;