"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Helper = require('../_coreUtils/Helper');

var helper = new Helper();

var DescriptiveGroup = require('../DescriptiveIncidents/DescriptiveGroup');

var _TREECONST = require('../Tree/_CONST');

var Playable =
/*#__PURE__*/
function (_DescriptiveGroup) {
  _inherits(Playable, _DescriptiveGroup);

  function Playable(attrs, props) {
    var _this;

    _classCallCheck(this, Playable);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Playable).call(this, attrs, props));
    _this.runTimeInfo = {
      currentMillisecond: 0,
      state: 'idle' // supported states: idle, playing, paused, blocked, armed

    };
    /**
      @member {object} - listeners are functions to be executed on time change of the Clip.
      It has the following format:
     listeners: {
        listener_id: {
                 funct : the function to be executed
                 threshold : the threshold of delta
                 roundTo : round millisecond
             },
             listener_id: {
                 funct : the function to be executed
                 threshold : the threshold of delta
                 roundTo : round millisecond
             },
             ...
       }
       */

    _this.listeners = {}; // previousTimeStamp is a property holding the last timestamp that the
    // requestAnimationFrame ran

    _this.previousTimeStamp = -1;
    _this.speed = 1;
    return _this;
  }
  /*********************** execution methods  *********************
   ****************************************************************/


  _createClass(Playable, [{
    key: "_setState",
    value: function _setState(newState) {
      if (newState != this.runTimeInfo.state) {
        this.runTimeInfo.state = newState; // the only timer and the only responsible for Clip execution is the Clip
        // All Incidents contained on a Clip are been executed by the Clip itself via its channels.
        // Thus, the only Incidents that need to know about the state of the root Clip
        // at any time are only the Clips

        this.putMessageOnPipe('setState', newState, 'Clips', {
          selfExecute: false,
          direction: _TREECONST._DIRECTIONS._DOWN
        });

        for (var key in this.listeners) {
          var listner = this.listeners[key];
          listner.funct(this.runTimeInfo.currentMillisecond, newState);
        }
      }
    }
  }, {
    key: "handleSetState",
    value: function handleSetState(target, payload) {
      this._setState(payload);
    } // execution methods

  }, {
    key: "play",
    value: function play() {
      var _this2 = this;

      var debug = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.runTimeInfo.state === 'idle' || this.runTimeInfo.state === 'paused' || this.runTimeInfo.state === 'armed' || this.runTimeInfo.state === 'transitional' || this.runTimeInfo.state === "blocked") {
        if (this.runTimeInfo.state === 'paused') {
          var delta = new Date().getTime() - this.pauseMoment;
          this.previousTimeStamp += delta;
        }

        this._setState('playing');

        this.onPlay();

        if (debug === false) {
          window.requestAnimationFrame(function (timestamp) {
            _this2.step(timestamp);
          });
        }
      }
    }
  }, {
    key: "pause",
    value: function pause() {
      if (this.runTimeInfo.state === 'playing') {
        this._setState('paused');

        this.pauseMoment = new Date().getTime();
        this.onWait();
      }
    }
    /* armed state means the Clip is on paused state after transition */

  }, {
    key: "arm",
    value: function arm() {
      if (this.runTimeInfo.state === 'transitional') {
        this._setState('armed');
      }
    }
  }, {
    key: "complete",
    value: function complete() {
      this._setState('idle');

      this.previousTimeStamp = -1;
    }
    /* in order to start a journey via the TimeCapsule the Playable needs first to stop */

  }, {
    key: "stop",
    value: function stop() {
      this._setState('transitional');

      this.previousTimeStamp = -1;
    }
  }, {
    key: "block",
    value: function block() {
      this._setState('blocked');

      this.previousTimeStamp = -1;
    }
  }, {
    key: "onPlay",
    value: function onPlay() {}
  }, {
    key: "onWait",
    value: function onWait() {}
  }, {
    key: "playableProgress",
    value: function playableProgress(fraction, millisecond) {
      if (this.isTheRootClip) {
        for (var key in this.listeners) {
          var listner = this.listeners[key]; // if the listener is only for state change continue

          if (listner.onlyOnStateChange === true) {
            continue;
          } // console.log(`Math.abs(${milliseconds} + ${listner.cavaDelta} - ${this.runTimeInfo.currentMillisecond}) > ${listner.threshold}`);


          if (Math.abs(millisecond + listner.cavaDelta - this.runTimeInfo.currentMillisecond) > listner.threshold) {
            listner.funct(helper.roundNumberTo(millisecond, listner.roundTo), this.runTimeInfo.state);
            listner.cavaDelta = 0;
          } else {
            listner.cavaDelta += Math.abs(millisecond - this.runTimeInfo.currentMillisecond);
          }
        }

        this.onProgress(fraction, millisecond);
        this.runTimeInfo.currentMillisecond = millisecond;
        return true;
      }

      return false;
    }
  }, {
    key: "step",
    // *******************************************************
    // STEP FUNCTION
    value: function step(timestamp) {
      var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (this.runTimeInfo.state !== 'playing') {
        return;
      }

      var that = this;

      if (this.previousTimeStamp === -1) {
        this.previousTimeStamp = timestamp;
      } // progressStep is the progress made from previousTimeStamp both in milliseconds and in fraction [0 to 1]


      var progress = {
        milliseconds: Math.round(this.runTimeInfo.currentMillisecond + (timestamp - this.previousTimeStamp) * this.speed),
        fraction: (this.runTimeInfo.currentMillisecond + (timestamp - this.previousTimeStamp) * this.speed) / this.duration
      };

      if (progress.fraction >= 1) {
        this.playableProgress(1, this.duration);
        this.complete();
        return;
      } else if (progress.fraction < 0) {
        this.playableProgress(0, 0);
        this.complete(); // this.broadcastEvent('state-change', { oldState: "playing", newState: "idle" });

        return;
      }

      this.playableProgress(progress.fraction, progress.milliseconds);
      this.previousTimeStamp = timestamp;

      if (debug === false) {
        window.requestAnimationFrame(that.step.bind(that));
      }
    } // ************ PUB SUB ********************
    // *****************************************

    /**
      By subscribing a module can get notified about changes on the Clip's time
      subscribe method subscribes a function to the time change dispatcher. As Clip uses requestAnimationFrame for its timing
      each cyrcle / step gets the current time and subtracts the previous time so it know how many milliseconds has elapsed
      since last step. Subscribers can set to get informed about time changes only if the delta is greater than a given
      number (e.g. greater than 300ms). That property is passed as the second argument "threshold".
      Finally if any of the subscribers want the Scene to provide back a rounded number of the milliseconds. Options:
        - 1 (round it on its actual units
       - 10 (round it on tenths)
       - 100 (round it on hundreds)
       - 1000 (round it on thousands)
      the first argument provides an id to the listener for future reference (deletion etc)
      the second argument is a function that takes two arguments: millisecond, state (current millisecond of the Scene
      and the state of it  */

  }, {
    key: "subscribe",
    value: function subscribe(id, funct, threshold, roundTo) {
      var onlyOnStateChange = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

      if (!threshold) {
        threshold = 0;
      }

      if (!roundTo) {
        roundTo = 1; // round second to its units, meaning leave it as it is
      }

      this.listeners[id] = {
        funct: funct,
        threshold: threshold,
        roundTo: roundTo,
        cavaDelta: 0,
        onlyOnStateChange: onlyOnStateChange
      };
    }
  }, {
    key: "unsubscribe",
    value: function unsubscribe(id) {
      if (Object.prototype.hasOwnProperty.call(this.listeners, id)) {
        delete this.listeners[id];
      }
    }
  }, {
    key: "subscribeToDurationChange",
    value: function subscribeToDurationChange(funct) {
      if (this.isTheRootClip) {
        this.realClip.subscribeToDurationChange(funct);
        return true;
      }

      return false;
    }
  }, {
    key: "executionSpeed",
    set: function set(speed) {
      if (!this.isTheRootClip) {
        return false;
      }

      this.speed = parseFloat(speed);
    }
  }]);

  return Playable;
}(DescriptiveGroup);

module.exports = Playable;