"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Helper = require('../_coreUtils/Helper');

var helper = new Helper();

var Group = require('../BaseClasses/Group');

var selfContainedIncidentsNpmName = '@kissmybutton/self-contained-incidents'; // TODO remove this

var _TREECONST = require('../Tree/_CONST');

var ExtendableClip =
/*#__PURE__*/
function (_Group) {
  _inherits(ExtendableClip, _Group);

  /**
   * @param {object} props - an object that should contain all of the following keys:
   * - html (the html template to render)
   * - css (the css template of the isolated tree)
   * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)
   * - host (an Element object that will host the isolated tree)
   * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)
   * - type (optional, defaults to "iframe") the type of the Clip. It can be one of the:
   *  - iframe
   *  - plain
   */
  function ExtendableClip(attrs, props) {
    var _this;

    _classCallCheck(this, ExtendableClip);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ExtendableClip).call(this, attrs, props));
    _this.attrs = attrs;
    _this.props = props;
    _this.isTheClip = true;
    _this.blockingWaitings = {};
    /**
     * The cnannels attribute holds a list of all intantiated Channels of the Incidents belonging to the clip
     * this attribute is only valuable when the Group becomes the Clip
     * The format of the attribute is:
     *  key-value pairs in the manner:
     * <mc_plugin_npm_name>: Channel object
     */

    _this.instantiatedChannels = {};
    _this.isHostedClip = true;
    /**
     * The instantiatedCopiesContexts is a key-value pairs colleciton holding the
     * contexts of all instantiated ClipCopies
     **/

    _this.instantiatedCopiesContexts = {};

    _this.onClipInitialise();

    _this.runTimeInfo = _this.props.runTimeInfo;
    _this.durationSubs = []; // the audioClip property defines wether the Clip is Audio or not. Defaults to false
    // and should be overiten to true on Audio Clip

    _this.audioClip = false;
    _this.contextReady = true;
    return _this;
  }

  _createClass(ExtendableClip, [{
    key: "onClipInitialise",
    value: function onClipInitialise() {// called when group gets initialised
    }
  }, {
    key: "contextLoading",
    value: function contextLoading() {
      this.contextReady = false;
    }
  }, {
    key: "contextLoaded",
    value: function contextLoaded() {
      this.contextReady = true;
      this.unblock();
    }
    /**
     * This method is been called when a new ClipCopy enters the real tree successfully.
     * @param {object} contextData - keys: clipId, context
     **/

  }, {
    key: "addContext",
    value: function addContext(contextData) {
      this.instantiatedCopiesContexts[contextData.clipId] = contextData.context;
      contextData.instantiatedCopiesContexts = this.instantiatedCopiesContexts;
      var res = this.putMessageOnPipe('addContext', contextData, {}, {
        selfExecute: false,
        direction: _TREECONST._DIRECTIONS._DOWN
      }); // if the added context is the first one to enter the realClip we must
      // recalculate the scratch values of all of our first Incidents on our instantiatedChannels

      if (Object.keys(this.instantiatedCopiesContexts).length === 1) {
        // if it is the first one to be added
        for (var key in this.instantiatedChannels) {
          this.instantiatedChannels[key].recalcScratchValues(contextData.clipId);
        } // also we store this non fragmented context on our context so it can be
        // used on Incidents addition for calculating scratch values


        this.context.nonFragmentedContext = contextData.context;
      }

      return res;
    }
    /*
    ExtendableClip (as its name implies) is a Class that should be extended by
    any specific kind of Clip, such as Fragmented or SCGroup. This method must
    be overitten by the new Classes. This definition here is just for reference / help
    purposes
    */

  }, {
    key: "exportConstructionArguments",
    value: function exportConstructionArguments() {
      return {
        attrs: this.attrs,
        props: this.props
      };
    }
    /**
     * completely resizes the Clip without any checks
     */

  }, {
    key: "_resize",
    value: function _resize(durationFraction) {
      for (var key in this.instantiatedChannels) {
        this.instantiatedChannels[key]._resize(durationFraction);
      }

      this.setNewDuration(this.duration * durationFraction);

      for (var i = 0; i < this.durationSubs.length; i++) {
        this.durationSubs[i](this.duration);
      }
    }
    /*********************************************************
    Editing commands input methods
    *********************************************************/

    /**
     * This command comes form the Clip's parent Descriptor class. The payload
     * is identical to the payload that comes to the Description class:
     * {
     *  incident: the Descriptive Incident to be added
     *  millisecond: the millisecond to add it
     *  parentGroupId: the id of the Group to which we want to the Incident to
     * }
     */

  }, {
    key: "addIncident",
    value: function addIncident(payload) {
      var _this2 = this;

      var candidates = this.putMessageOnPipe('addIncident', {
        incident: payload.incident,
        millisecond: payload.millisecond,
        parentGroupId: payload.parentGroupId,
        contextData: {
          clipId: this.id,
          context: this.context,
          instantiatedCopiesContexts: this.instantiatedCopiesContexts
        },
        audio: this.audioClip
      }, payload.parentGroupId, {
        selfExecute: true,
        direction: _TREECONST._DIRECTIONS._DOWN
      }); // concatenate candidates
      // console.log(candidates);

      var totalIncidentsByPlugin = {};

      for (var i = 0; i < candidates.length; i++) {
        var incidentsByPlugin = candidates[i].response.getIncidentsByChannel(candidates[i].positionDelta + payload.millisecond);

        for (var pluginName in incidentsByPlugin) {
          var _totalIncidentsByPlug;

          if (!Object.prototype.hasOwnProperty.call(totalIncidentsByPlugin, pluginName)) {
            totalIncidentsByPlugin[pluginName] = [];
          }

          (_totalIncidentsByPlug = totalIncidentsByPlugin[pluginName]).push.apply(_totalIncidentsByPlug, _toConsumableArray(incidentsByPlugin[pluginName]));
        }
      } // console.log(totalIncidentsByPlugin);


      var res = this.checkAddition(totalIncidentsByPlugin);

      if (res.result === true) {
        var successCallback = function successCallback() {
          res.execute(); // up to that point the only context Incident that has been initialised on the
          // ContextAwareIncidents of the candidates is the original context of the
          // ExtendableClip.

          for (var _i = 0; _i < candidates.length; _i++) {
            candidates[_i].responder.addChild(candidates[_i].response, payload.millisecond); // recalculate duration the groups that we added
            // the incidents to along with their parents


            candidates[_i].responder.putMessageOnPipe('recalcDuration', {}, 'Groups', {
              selfExecute: true,
              direction: _TREECONST._DIRECTIONS._UP
            }); // we also need to add every existing (copied) context to the ContextAwareIncidents
            // created on the candidates process


            for (var contextKey in _this2.instantiatedCopiesContexts) {
              candidates[_i].responder.putMessageOnPipe('addContext', {
                clipId: contextKey,
                context: _this2.instantiatedCopiesContexts[contextKey]
              }, 'ContextAwareIncidents', {
                selfExecute: false,
                direction: _TREECONST._DIRECTIONS._DOWN
              });
            }
          }
        };

        return {
          result: true,
          execute: successCallback
        };
      }

      return res;
    } // *******************************************************
    // INCIDENTS MANAGEMENT METHODS
    // POLYMORPHISM APPLIED. IF THE GROUP HAS NO PARENT IT ACTS AS A SCENE. IF THE GROUP HAS PARENT IT ACTS AS
    // A "TRANSPARENT GROUP"

    /**
     * The method returns either:
        {
            result:true,
            execute: // an array of functions that when executed it will add the Incidents on the Channels
        }
        or
        {
            result: false,
            errors
        }
    */

  }, {
    key: "checkAddition",
    value: function checkAddition(incidentsById) {
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "all-or-nothing";
      // prepare the return payload
      var toReturnResult = true;
      var toReturnErrors = [];
      var toReturnExecutables = []; // for each key of the incidentsById object perform the check

      for (var key in incidentsById) {
        // if the clip had no channel instantiated for the specific key (plugin id) yet create it
        if (!Object.prototype.hasOwnProperty.call(this.instantiatedChannels, key)) {
          // intstantiate the channel of the plugin by using the reference to the class definition stored on
          // the very first incident of the array
          // console.log(incidentsById[key][0].incident.plugin_channel_class);
          this.instantiatedChannels[key] = new incidentsById[key][0].incident.plugin_channel_class({
            runTimeInfo: this.runTimeInfo,
            context: this.context,
            subscribe: this.props.subscribe // all channels can subscribe to state or current millisecond changes

          });
        } // perform the check


        var pluginResult = this.instantiatedChannels[key].addIncidents(incidentsById[key], type);
        toReturnResult = toReturnResult && pluginResult.result;

        if (pluginResult.result === false) {
          toReturnErrors = toReturnErrors.concat(pluginResult.errors);
        } else {
          toReturnExecutables.push(pluginResult.execute);
        }
      } // enf of iteration on the incidentsById keys


      var toReturnExecute = function toReturnExecute() {
        for (var i = 0; i < toReturnExecutables.length; i++) {
          toReturnExecutables[i]();
        }
      };

      var additionResult = {
        result: toReturnResult,
        errors: toReturnErrors,
        execute: toReturnExecute
      };
      return additionResult;
    }
    /**
     * This command comes form the Clip's parent Descriptor class. The payload
     * is identical to the payload that comes to the Description class:
     * {
     *  incident: the Descriptive Incident to be repositioned
     *  millisecond: the new millisecond to put it
     *  parentGroupId: the id of the
     * }
     */

  }, {
    key: "moveIncident",
    value: function moveIncident(payload) {
      var candidates = this.putMessageOnPipe('moveIncident', {
        incidentId: payload.id,
        millisecond: payload.millisecond,
        parentGroupId: payload.parentGroupId,
        contextData: {
          clipId: this.id,
          context: this.context
        },
        audio: this.audioClip
      }, payload.parentGroupId, {
        selfExecute: true,
        direction: _TREECONST._DIRECTIONS._DOWN
      });
      var totalIncidentsByPlugin = {};

      for (var i = 0; i < candidates.length; i++) {
        var incidentsByPlugin = candidates[i].response.getIncidentsByChannel(candidates[i].positionDelta + payload.millisecond);

        for (var pluginName in incidentsByPlugin) {
          var _totalIncidentsByPlug2;

          if (!Object.prototype.hasOwnProperty.call(totalIncidentsByPlugin, pluginName)) {
            totalIncidentsByPlugin[pluginName] = [];
          }

          (_totalIncidentsByPlug2 = totalIncidentsByPlugin[pluginName]).push.apply(_totalIncidentsByPlug2, _toConsumableArray(incidentsByPlugin[pluginName]));
        }
      }

      var res = this.checkMove(totalIncidentsByPlugin, payload.positionDelta);

      if (res.result === true) {
        var successCallback = function successCallback() {
          res.execute();

          for (var _i2 = 0; _i2 < candidates.length; _i2++) {
            candidates[_i2].responder.editPosition(candidates[_i2].response.id, payload.millisecond); // recalculate duration the groups that we added
            // the incidents to along with their parents


            candidates[_i2].responder.putMessageOnPipe('recalcDuration', {}, 'Groups', {
              selfExecute: true,
              direction: _TREECONST._DIRECTIONS._UP
            });
          }
        };

        return {
          result: true,
          execute: successCallback
        };
      }

      return res;
    }
    /**
     * The checkEdit method serves exactly what its name implies. To check if the edit of an Incident (edit of Incident's position given in milliseconds delta)
     * is valid and accepted, according to the rules defined on the channels.
     * The method boobles up until it reaches the Clip.
     * @param {object} incident - the incident to edit
     * @param {int} millisecondsDelta - the milliseconds delta of the Incident's start time
     The method should return either:
        {
            result:true,
            execute: // an array of functions that when executed it will edit the Incidents on the Channels
        }
        or
        {
            result: false,
            errors
        }
    */

  }, {
    key: "checkMove",
    value: function checkMove(incidentsById, millisecondsDelta) {
      // prepare the return payload
      var toReturnResult = true;
      var toReturnErrors = [];
      var toReturnExecutables = []; // for each key of the incidentsById object perform the check

      for (var key in incidentsById) {
        // perform the check
        var pluginResult = this.instantiatedChannels[key].editIncidents(incidentsById[key], millisecondsDelta);
        toReturnResult = toReturnResult && pluginResult.result;

        if (pluginResult.result === false) {
          toReturnErrors = toReturnErrors.concat(pluginResult.errors);
        } else {
          toReturnExecutables.push(pluginResult.execute);
        }
      } // enf of iteration on the incidentsById keys


      var toReturnExecute = function toReturnExecute() {
        for (var i = 0; i < toReturnExecutables.length; i++) {
          toReturnExecutables[i]();
        }
      };

      var editResult = {
        result: toReturnResult,
        errors: toReturnErrors,
        execute: toReturnExecute
      };
      return editResult;
    }
  }, {
    key: "removeIncident",
    value: function removeIncident(payload) {
      var candidates = this.putMessageOnPipe('removeIncident', {
        incidentId: payload.id,
        parentGroupId: payload.parentGroupId,
        contextData: {
          clipId: this.id,
          context: this.context
        },
        audio: this.audioClip
      }, payload.parentGroupId, {
        selfExecute: true,
        direction: _TREECONST._DIRECTIONS._DOWN
      });
      var totalIncidentsByPlugin = {};

      for (var i = 0; i < candidates.length; i++) {
        var incidentsByPlugin = candidates[i].response.getIncidentsByChannel();

        for (var pluginName in incidentsByPlugin) {
          var _totalIncidentsByPlug3;

          if (!Object.prototype.hasOwnProperty.call(totalIncidentsByPlugin, pluginName)) {
            totalIncidentsByPlugin[pluginName] = [];
          }

          (_totalIncidentsByPlug3 = totalIncidentsByPlugin[pluginName]).push.apply(_totalIncidentsByPlug3, _toConsumableArray(incidentsByPlugin[pluginName]));
        }
      }

      var res = this.checkDelete(totalIncidentsByPlugin);

      if (res.result === true) {
        var successCallback = function successCallback() {
          res.execute();

          for (var _i3 = 0; _i3 < candidates.length; _i3++) {
            candidates[_i3].responder.removeChild(candidates[_i3].response.id); // recalculate duration the groups that we added
            // the incidents to along with their parents


            candidates[_i3].responder.putMessageOnPipe('recalcDuration', {}, 'Groups', {
              selfExecute: true,
              direction: _TREECONST._DIRECTIONS._UP
            });
          }
        };

        return {
          result: true,
          execute: successCallback
        };
      }

      return res;
    }
    /**
     * The checkDelete method serves exactly what its name implies. To check if the deletion of an Incident
     * is valid and accepted, according to the rules defined on the channels.
     * The method boobles up until it reaches the Clip.
     * @param {object} incident - the incident to edit
      The result might be either:
        {
            result:true,
            execute: // an array of functions that when executed it will remove the Incident on the Channels
        }
        or
        {
            result: false,
            errors
        }
    */

  }, {
    key: "checkDelete",
    value: function checkDelete(incidentsById) {
      // prepare the return payload
      var toReturnResult = true;
      var toReturnErrors = [];
      var toReturnExecutables = []; // for each key of the incidentsById object perform the check

      for (var key in incidentsById) {
        // perform the check
        var pluginResult = this.instantiatedChannels[key].removeIncidents(incidentsById[key]);
        toReturnResult = toReturnResult && pluginResult.result;

        if (pluginResult.result === false) {
          toReturnErrors = toReturnErrors.concat(pluginResult.errors);
        } else {
          toReturnExecutables.push(pluginResult.execute);
        }
      } // enf of iteration on the incidentsById keys


      var toReturnExecute = function toReturnExecute() {
        for (var i = 0; i < toReturnExecutables.length; i++) {
          toReturnExecutables[i]();
        }
      };

      var removeResult = {
        result: toReturnResult,
        errors: toReturnErrors,
        execute: toReturnExecute
      };
      return removeResult;
    }
    /**
     * This command is invoked by the Clip's parent Descriptor class. The payload
     * is identical to the payload that comes to the Description class:
     * {
     *  id: the id of the Incident to resize
     *  newSize: the milliseconds of the new duration
     *  fraction: the division of the new duration to the current
     * }
     */

  }, {
    key: "resizeIncident",
    value: function resizeIncident(payload) {
      var candidates = this.putMessageOnPipe('resize', {
        incidentId: payload.id,
        newSize: payload.newSize,
        fraction: payload.fraction,
        contextData: {
          clipId: this.id,
          context: this.context
        },
        audio: this.audioClip
      }, payload.id, {
        selfExecute: false,
        direction: _TREECONST._DIRECTIONS._DOWN
      });
      var totalIncidentsByPlugin = {};

      for (var i = 0; i < candidates.length; i++) {
        var incidentsByPlugin = candidates[i].response.getIncidentsByChannel(candidates[i].positionDelta);

        for (var pluginName in incidentsByPlugin) {
          var _totalIncidentsByPlug4;

          if (!Object.prototype.hasOwnProperty.call(totalIncidentsByPlugin, pluginName)) {
            totalIncidentsByPlugin[pluginName] = [];
          }

          (_totalIncidentsByPlug4 = totalIncidentsByPlugin[pluginName]).push.apply(_totalIncidentsByPlug4, _toConsumableArray(incidentsByPlugin[pluginName]));
        }
      }

      var positionDelta = 0;

      if (candidates.length > 0) {
        positionDelta = candidates[0].positionDelta;
      }

      var res = this.checkResize(payload.fraction, totalIncidentsByPlugin, positionDelta);

      if (res.result === true) {
        var successCallback = function successCallback() {
          res.execute();

          for (var _i4 = 0; _i4 < candidates.length; _i4++) {
            candidates[_i4].responder.setNewDuration(payload.newSize);
          }
        };

        return {
          result: true,
          execute: successCallback
        };
      }

      return res;
    }
    /**
     * checks if a duration edit is feasible and doesn't cause conflicts
     * @param {int} duration - the new duration
     **/

  }, {
    key: "checkResize",
    value: function checkResize(durationFraction, incidentsById) {
      var adjustMillisecond = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      // prepare the return payload
      var toReturnResult = true;
      var toReturnErrors = [];
      var toReturnExecutables = []; // for each key of the incidentsById object perform the check

      for (var key in incidentsById) {
        // perform the check
        var adjustedIncidents = helper.systoleDiastoleProjections(incidentsById[key], durationFraction, adjustMillisecond);
        var pluginResult = this.instantiatedChannels[key].checkResizedIncidents(adjustedIncidents);
        toReturnResult = toReturnResult && pluginResult.result;

        if (pluginResult.result === false) {
          toReturnErrors = toReturnErrors.concat(pluginResult.errors);
        } else {
          toReturnExecutables.push(pluginResult.execute);
        }
      } // enf of iteration on the incidentsById keys


      var toReturnExecute = function toReturnExecute() {
        for (var i = 0; i < toReturnExecutables.length; i++) {
          toReturnExecutables[i]();
        }
      };

      var editResult = {
        result: toReturnResult,
        errors: toReturnErrors,
        execute: toReturnExecute
      };
      return editResult;
    }
  }, {
    key: "getIncidentsByChannel",

    /**
     * Returns an object with keys the keys of all the plugins Incidents of which appear in the
     * tree of the Group. All Incidents are projected to the Group's timeline.
     * The array includes the Group's projection too
     */
    value: function getIncidentsByChannel() {
      var adjustMillisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var incidentsByPlugin = {};
      incidentsByPlugin[selfContainedIncidentsNpmName] = [{
        millisecond: adjustMillisecond,
        incident: this,
        id: this.id
      }];
      return incidentsByPlugin;
    }
  }, {
    key: "setVolume",
    value: function setVolume(newVal) {
      this.volume = parseFloat(newVal); // this.putMessageOnPipe(pipeMessages._GAIN_CHANGE, { gain: newVal }, false, "down");
    }
    /**
     * Eventhough Clips have their own context, still they might belong to another Clip's
     * tree (CASI). In such a case this method gives the oportunity to set things up
     * and do operations related with their parent's context (such as subscribing to audio effect nodes)
     **/

  }, {
    key: "_onGetContextOnce",
    value: function _onGetContextOnce(parentClipContext) {
      return;
    } // special recalcDuration handling so any potential clip copies update their trees

  }, {
    key: "handleRecalcDuration",
    value: function handleRecalcDuration(target, payload) {
      // eslint-disable-line no-unused-vars
      if (this._calculateDuration()) {
        for (var i = 0; i < this.durationSubs.length; i++) {
          this.durationSubs[i](this.duration);
        }
      }

      return true;
    }
    /**
     * Method called on progress of the timed incident.
     * @param {float} fraction - a number from 0 to 1 representing the fraction of duration covered
     * @param {int} milliseconds - the number of milliseconds passed from start of the incident
     * @param {string} contextId - defaults to the id of the realClip itself. Don't forget that a realClip
     *      might belong to a selector Clip (so it's a Fragmented Clip), with many "real" ClipCopies. All ClipCopies hold
     *      a reference to this Clip via their "realClip" property. Whenever any
     *      of these ClipCopies progresses (via the onProgress method) calls
     *      the "onProgress" of the realClip, passing their id so the ContextAwareIncidents
     *      that will also progress via the Channels know which specific Incident to progress.
     *      That's the result of keeping just one real tree, belonging always to the realClip
     *      (either Fragmented or Hosted) ending to ContextAwareIncident leafs that
     *      are the ones to hold the ClipCopies instances.
     * @param {boolean} forceReset - set to true in cases we want full flash of the state
     */

  }, {
    key: "onProgress",
    value: function onProgress(fraction, milliseconds, contextId) {
      var forceReset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      if (this.contextReady === false) {
        this.setBlock();
        return;
      }

      if (!contextId) {
        contextId = this.id;
      }

      for (var key in this.instantiatedChannels) {
        var channel = this.instantiatedChannels[key];
        channel.moveTo(this.runTimeInfo.currentMillisecond, milliseconds, contextId, forceReset);
      }

      this.onAfterProgress(fraction, milliseconds);
    }
  }, {
    key: "onAfterProgress",
    value: function onAfterProgress(fraction, milliseconds) {}
  }, {
    key: "flash",
    value: function flash() {
      for (var key in this.instantiatedChannels) {
        var channel = this.instantiatedChannels[key];
        channel.moveTo(0, this.runTimeInfo.currentMillisecond, this.id, true);
      }
    } // duration changes pub/sub

  }, {
    key: "subscribeToDurationChange",
    value: function subscribeToDurationChange(method) {
      this.durationSubs.push(method);
    }
    /********************************************************/

    /******** BLOCKING WAITINGS SET / REMOVE ***************/

  }, {
    key: "handleSetBlockingWaiting",
    value: function handleSetBlockingWaiting(target, payload) {
      console.log('handling set blocking waiting');
      console.log(payload);
    }
  }, {
    key: "handleRemoveBlockingWaiting",
    value: function handleRemoveBlockingWaiting(target, payload) {
      console.log('handling remove blocking waiting');
      console.log(payload);
    }
  }, {
    key: "context",
    get: function get() {
      return this.ownContext;
    }
  }]);

  return ExtendableClip;
}(Group);

module.exports = ExtendableClip;