"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Playable = require('../Clip/Playable');

var _TREECONST = require('../Tree/_CONST');

var FragmentedClip = require('../Clip/FragmentedClip');

var Clip = require('../Clip/DOMClip');

var Channel = require('../Channels/Clip/ClipsChannel');

var incidentFromIngredients = require('../IncidentFromDefinition/incidentFromIngredients');

var ClipClone = require('../Clip/RootClipClone');

var AudioClip = require('../Audio/AudioClip');

var NullClip = require('../Clip/NullClip');

var rules = require('../_configuration/propsValidationRules');

var Helper = require('../_coreUtils/Helper');

var helper = new Helper();
/**
 * Along with the expected props for the Clip on the props support the audio key.
 * The audio can take one of the 3 following values:
 * - "on": The Clip has audio enabled
 * - "off": The Clip has audio disabled
 * - "only": The Clip is only audio
 *
 * Also, in the case audio is on or only the user should pass the "audioSources"
 * key containing all the audio sources they want to pass on the Audio Context
 * of their clip. Please check AudioClip for details on the expected format
 **/

var DescriptiveClip =
/*#__PURE__*/
function (_Playable) {
  _inherits(DescriptiveClip, _Playable);

  function DescriptiveClip(attrs) {
    var _this;

    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, DescriptiveClip);

    var attrsToPass, propsToUse;

    if (props === null) {
      attrsToPass = {};
      propsToUse = attrs;
    } else {
      // else, in case the user has passed two arguments then both should be used
      attrsToPass = attrs;
      propsToUse = props;
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(DescriptiveClip).call(this, attrsToPass, propsToUse));

    var propsValidation = _this._validateProps();

    if (propsValidation.result === false) {
      return _possibleConstructorReturn(_this, propsValidation);
    } // isTheRootClip defines whether the Clip is the root or not. It depends on
    // the host or selector parameter passed on props (if host is present then
    // the Clip is the root Clip while if the Clip gets initialised by a selector
    // is not)


    _this.isTheRootClip = false; // check if

    var ingredients = {
      id: _this.id,
      attrs: attrsToPass,
      props: _objectSpread({}, propsToUse, {
        html: Object.prototype.hasOwnProperty.call(propsToUse, "html") ? propsToUse.html : _this.html,
        css: Object.prototype.hasOwnProperty.call(propsToUse, "css") ? propsToUse.css : _this.css,
        fonts: Object.prototype.hasOwnProperty.call(propsToUse, "fonts") ? propsToUse.fonts : _this.fonts,
        runTimeInfo: _this.runTimeInfo,
        subscribe: _this.subscribe.bind(_assertThisInitialized(_this))
      }),
      plugin_npm_name: _this.constructor.plugin_npm_name,
      Channel: _this.constructor.Channel,
      DescriptiveIncident: _assertThisInitialized(_this)
    }; // Decide what kind of audio (or non-audio) Clip we are dealing with

    _this.audio = "on";

    if (Object.prototype.hasOwnProperty.call(_this.constructor, 'audio')) {
      _this.audio = _this.constructor.audio;
    }

    if (Object.prototype.hasOwnProperty.call(propsToUse, 'audio')) {
      _this.audio = propsToUse.audio;
    } // decide if this is the root clip


    if (Object.prototype.hasOwnProperty.call(propsToUse, "selector") && propsToUse.selector !== undefined && _this.constructor.customClip !== true) {
      ingredients.Incident = FragmentedClip; // TODO it doesn't take in account the get html and get css of the Descriptive Clip
    } else if (Object.prototype.hasOwnProperty.call(propsToUse, "selector") && propsToUse.selector !== undefined && _this.constructor.customClip === true) {
      delete ingredients.props.selector;
      var FragmentWrapper = new FragmentedClip({
        html: '<div id="clip-container"></div>'
      });
      ingredients.props.host = FragmentWrapper.rootElement;
      ingredients.Incident = _this.constructor.Incident;
    } else if (_this.audio === "only" && _this.props.root !== true) {
      // audioClips can never be the root
      _this.isTheRootClip = false;
    } else {
      _this.isTheRootClip = true;
      /*
      blockingWaitings are been triggered by Incidents when there is the
      need to halt the Clip's execution and wait. As an example a blocking
      waiting can be set by an Audio Playback Incident when the audio has
      not been loaded yet.
      Each blocking waiting has an id and via the same id the waiting can be
      unblocked.
      The blockingWaitings property of the root Clip is a collection with
      keys the blocking waitings ids and values the description of each waiting
      which consists of:
      {
          id
          description
          incidentId
      }
      The blocking waitings are triggered by real Incidents living on the real
      Clips of the Descriptive Clip (either the audioClip or the realClip).
      The root that a waiting set or unset follows is from any real incident
      up to its ContextAware Incident and from there
      up to the real Clip and from thre to its DescriptiveTree and from there
      all the way up to the root Descriptive Clip.
      Blocking waitings must always be triggered on the "onProgress" or on
      the "play" methods of Incidents. Setting a blocking waiting from anywhere
      else is an error
      */

      _this.blockingWaitings = {};
      ingredients.Incident = _this.constructor.Incident;
    } // we initialise real and audio clips of the Clip by checking the static audio
    // property
    // the property this.audio helps incidentFromDescription identify if the Incident
    // participates or not on the audioClip. By default is "on" but if the props.audio is set to off
    // it turns to "off" so the DC gets totally ignored on the addition process on audio clip

    /* The audio value is set in the following manner
        - first we check if the Class has a static audio parameter and if yes we keep it
        - then we check if this.props has the audio key and if yes we keep this one
        - otherwise we use the default ("on")
    */


    if (_this.audio === 'on' || _this.audio === 'off') {
      _this.realClip = incidentFromIngredients(ingredients);
    } else {
      _this.realClip = new NullClip();
    }

    if (_this.audio === 'on' || _this.audio === 'only') {
      var audioIngredients = {
        id: _this.id,
        attrs: {},
        props: {
          audioSources: Object.prototype.hasOwnProperty.call(propsToUse, "audioSources") ? propsToUse.audioSources : _this.audioSources,
          runTimeInfo: _this.runTimeInfo,
          subscribe: _this.subscribe.bind(_assertThisInitialized(_this))
        },
        plugin_npm_name: _this.constructor.plugin_npm_name,
        Channel: _this.constructor.Channel,
        Incident: AudioClip,
        DescriptiveIncident: _assertThisInitialized(_this)
      };
      _this.audioClip = incidentFromIngredients(audioIngredients);
    } else {
      _this.audio = "off";
      _this.audioClip = new NullClip();
    } // passiveAddition is a flag property indicating that any Incident to be
    // added to the Clip will be passive. It initialises with value = false
    // on DescriptiveGroup where it's originaly defined.
    // Here we change its value just before the buildTree method execution
    // so all Incidents added on it get the "passive" flag and don't get
    // exported on the exportDefinition method. Once the buildTree method
    // finishes we set it back to its original value (false)


    _this.passiveAddition = true;

    _this._buildTree();

    _this.passiveAddition = false;
    return _this;
  }

  _createClass(DescriptiveClip, [{
    key: "_validateProps",
    value: function _validateProps() {
      return helper.validateProps({
        props: this.props
      }, rules.clipPropsRule, this.constructor);
    }
  }, {
    key: "_buildTree",

    /*
    the _buildTree method acts as a proxy to the buildTree method defined by the
    developers. The reason for this is that the actual buildTree method should
    be executed in different order on Groups and on Clips (that extend Groups).
    Calling the super on constructor fires the _buildTree execution on the
    Group's constructor but this breaks on Clip as the realClip has not been
    initialised yet.
    */
    value: function _buildTree() {
      if (this.realClip === undefined) {
        return;
      }

      this.buildTree();
    }
    /**
     * When the resize command is given directly to a DescriptiveClip no checks
     * need to be performed.
     * DescriptiveClip directly invokes the _resize method of ExtendableClip which
     * resizes the full clip
     */

  }, {
    key: "resize",
    value: function resize(newSize) {
      this.realClip._resize(newSize / this.duration);

      this.audioClip._resize(newSize / this.duration);

      this.duration = newSize;
      this.putMessageOnPipe('recalcDuration', {}, 'Groups', {
        selfExecute: false,
        direction: _TREECONST._DIRECTIONS._UP
      });
      this.putMessageOnPipe('flash', {}, 'RootClip', {
        selfExecute: true,
        direction: _TREECONST._DIRECTIONS._UP
      });
      return {
        result: true
      };
    }
    /*************************** HANDLING METHODS *******************************/

  }, {
    key: "handleCheckForClip",
    value: function handleCheckForClip(target, payload) {
      // eslint-disable-line no-unused-vars
      return true;
    }
  }, {
    key: "handleCheckAddition",
    value: function handleCheckAddition(target, payload) {
      /* Is the responsibility of the DescriptiveClip to pass the addition request
      to its real clip and expect for a response. */
      var res = this.realClip.addIncident(payload);
      var audioRes = this.audioClip.addIncident(payload);

      if (res.result === true && audioRes.result === true) {
        res.execute();
        audioRes.execute();
        this.putMessageOnPipe('flash', {}, 'RootClip', {
          selfExecute: true,
          direction: _TREECONST._DIRECTIONS._UP
        });
        return {
          result: true
        };
      }

      return res;
    }
  }, {
    key: "handleCheckMove",
    value: function handleCheckMove(target, payload) {
      var res = this.realClip.moveIncident(payload);
      var audioRes = this.audioClip.moveIncident(payload);

      if (res.result === true && audioRes.result === true) {
        res.execute();
        audioRes.execute();
        this.putMessageOnPipe('flash', {}, 'RootClip', {
          selfExecute: true,
          direction: _TREECONST._DIRECTIONS._UP
        });
        return {
          result: true
        };
      }

      return res;
    }
  }, {
    key: "handleCheckDeletion",
    value: function handleCheckDeletion(target, payload) {
      var res = this.realClip.removeIncident(payload);
      var audioRes = this.audioClip.removeIncident(payload);

      if (res.result === true && audioRes.result === true) {
        res.execute();
        audioRes.execute();
        this.putMessageOnPipe('flash', {}, 'RootClip', {
          selfExecute: true,
          direction: _TREECONST._DIRECTIONS._UP
        });
        return {
          result: true
        };
      }

      return res;
    }
  }, {
    key: "handleCheckResize",
    value: function handleCheckResize(target, payload) {
      var res = this.realClip.resizeIncident(payload);
      var audioRes = this.audioClip.resizeIncident(payload);

      if (res.result === true && audioRes.result === true) {
        res.execute();
        audioRes.execute();
        this.putMessageOnPipe('flash', {}, 'RootClip', {
          selfExecute: true,
          direction: _TREECONST._DIRECTIONS._UP
        });
        return {
          result: true
        };
      }

      return res;
    }
  }, {
    key: "handleFlash",
    value: function handleFlash(target, payload) {
      // eslint-disable-line no-unused-vars
      if (this.isTheRootClip) {
        this.flash();
      } else {
        return this.bypass();
      }
    }
    /****************** BLOCKING WAITINGS HANDLING **************************/

    /***********************************************************************/

  }, {
    key: "handleSetBlock",
    value: function handleSetBlock(target, payload) {
      // only accepts blocks if is the root clip and if it's playing
      if (this.isTheRootClip) {
        if (this.runTimeInfo.state === "transitional") {
          return;
        }

        if (this.runTimeInfo.state !== 'blocked') {
          this.statusBeforeBlock = this.runTimeInfo.state;
        }

        this.blockingWaitings[payload.id] = payload;
        this.block();
      } else {
        return this.bypass();
      }
    }
  }, {
    key: "handleUnBlock",
    value: function handleUnBlock(target, payload) {
      if (this.isTheRootClip) {
        if (Object.prototype.hasOwnProperty.call(this.blockingWaitings, payload.id)) {
          delete this.blockingWaitings[payload.id];

          if (Object.keys(this.blockingWaitings).length === 0) {
            if (this.statusBeforeBlock === "playing") {
              this.previousTimeStamp = -1;
              this.play();
            } else {
              this.arm();
            }
          }
        }
      } else {
        return this.bypass();
      }
    }
    /* empty blocking waitings on transition start */

  }, {
    key: "stop",
    value: function stop() {
      _get(_getPrototypeOf(DescriptiveClip.prototype), "stop", this).call(this);

      this.blockingWaitings = {};
    }
    /***********************************************************************/

    /***********************************************************************/

  }, {
    key: "onProgress",
    value: function onProgress(fraction, millisecond) {
      this.realClip.onProgress(fraction, millisecond);
      this.audioClip.onProgress(fraction, millisecond);
    }
    /*************************************************************/

  }, {
    key: "paste",
    value: function paste(host) {
      if (this.isTheRootClip) {
        var clipClone = new ClipClone({
          host: host,
          descriptiveIncident: this
        });
        return clipClone;
      }

      return null;
    }
  }, {
    key: "flash",
    value: function flash() {
      this.realClip.flash();
    }
  }, {
    key: "setVolume",
    value: function setVolume(vol) {
      if (vol < 0 || vol > 1) {
        return {
          result: false,
          errors: [{
            type: 'invalid volume number'
          }]
        };
      } else if (this.audio === 'off') {
        return {
          result: false,
          errors: [{
            type: 'can not set volume of Clip with audio off'
          }]
        };
      } else {
        this.audioClip.setVolume(vol);
        return {
          result: true
        };
      }
    }
  }, {
    key: "selectorToPassToChildren",
    get: function get() {
      return null; // the Clip (any Clip) resets the selection cascading
    }
  }, {
    key: "inheritedSelector",
    get: function get() {
      return this._inheritedSelector;
    },
    set: function set(value) {
      this._inheritedSelector = value;
    }
  }, {
    key: "html",
    get: function get() {
      return '';
    }
  }, {
    key: "css",
    get: function get() {
      return '';
    }
  }, {
    key: "fonts",
    get: function get() {
      return [];
    }
  }, {
    key: "audioSources",
    get: function get() {
      return [];
    }
  }]);

  return DescriptiveClip;
}(Playable);

_defineProperty(DescriptiveClip, "isClip", true);

_defineProperty(DescriptiveClip, "Incident", Clip);

_defineProperty(DescriptiveClip, "plugin_npm_name", "@kissmybutton/self-contained-incidents");

_defineProperty(DescriptiveClip, "Channel", Channel);

_defineProperty(DescriptiveClip, "ClassName", "Clip");

module.exports = DescriptiveClip;