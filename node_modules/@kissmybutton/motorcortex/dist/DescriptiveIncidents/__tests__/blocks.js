"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var DC = require('../DescriptiveClip');

var MC = require('../../main');

var MediaPlayIncident = require('../../BaseClasses/MediaPlayIncident');

var TimeCapsule = new MC.TimeCapsule();

var MyAudioPlayback =
/*#__PURE__*/
function (_MediaPlayIncident) {
  _inherits(MyAudioPlayback, _MediaPlayIncident);

  function MyAudioPlayback() {
    _classCallCheck(this, MyAudioPlayback);

    return _possibleConstructorReturn(this, _getPrototypeOf(MyAudioPlayback).apply(this, arguments));
  }

  _createClass(MyAudioPlayback, [{
    key: "play",
    value: function play(ms) {
      this.setBlock('Audio-blocking-description');
    }
  }]);

  return MyAudioPlayback;
}(MediaPlayIncident);

var myClip, casi;

var MyPluginIncident =
/*#__PURE__*/
function (_MC$API$MonoIncident) {
  _inherits(MyPluginIncident, _MC$API$MonoIncident);

  function MyPluginIncident() {
    _classCallCheck(this, MyPluginIncident);

    return _possibleConstructorReturn(this, _getPrototypeOf(MyPluginIncident).apply(this, arguments));
  }

  _createClass(MyPluginIncident, [{
    key: "onGetContext",
    value: function onGetContext() {// console.log('got context');
    }
  }, {
    key: "onProgress",
    value: function onProgress(t) {
      // eslint-disable-line no-unused-vars
      if (this.isBlocked === true) {
        this.unblock();
      } else {
        this.setBlock('Blocking-description');
      }
    }
  }]);

  return MyPluginIncident;
}(MC.API.MonoIncident);

var testPlugin = {
  npm_name: '@kissmybutton/test-plugin',
  name: 'Test Plugin',
  incidents: [{
    exportable: MyPluginIncident,
    name: 'MPInc'
  }, {
    exportable: MyAudioPlayback,
    name: 'MPMediaPlayback'
  }],
  audio: true
};
var TestPlugin = MC.loadPlugin(testPlugin);
test("set blocking waiting to Clip while playing. Expect to block", function () {
  document.body.innerHTML = "<div id=\"clip-container\"></div>";
  myClip = new DC({
    html: "\n            <div id=\"my-root-div\">\n                <div id=\"element-1\" class=\"my-class\" data-motorcortex2-id=\"my-class-1\"></div>\n                <div id=\"element-2\" class=\"my-class\" data-motorcortex2-id=\"my-class-2\"></div>\n                <div id=\"casi-container\"></div>\n            </div>",
    css: "\n            #my-root-div {\n                width: 800px;\n                height: 400px;\n            }\n            .my-class {\n                display: inline-block;\n                width: 50%;\n                height: 100%;\n            }\n        ",
    host: document.querySelector('#clip-container'),
    id: 'my-clip',
    audioSources: [{
      src: 'http://www.hochmuth.com/mp3/Tchaikovsky_Rococo_Var_orch.mp3',
      id: 'classic',
      classes: ['classic'],
      base64: false
    }]
  });
  var di1 = new TestPlugin.MPInc({
    animatedAttrs: {
      alpha: 1
    }
  }, {
    selector: '.my-class',
    duration: 1000,
    id: 'di1'
  });
  myClip.addIncident(di1, 0);
  myClip.play(true);
  myClip.playableProgress(100 / myClip.duration, 100);
  expect(Object.keys(myClip.blockingWaitings).length).toBe(2);
  expect(myClip.blockingWaitings[Object.keys(myClip.blockingWaitings)[0]].description).toBe('Blocking-description');
  expect(myClip.blockingWaitings[Object.keys(myClip.blockingWaitings)[1]].description).toBe('Blocking-description');
  expect(myClip.blockingWaitings[Object.keys(myClip.blockingWaitings)[0]].incidentId).toBe('di1');
  expect(myClip.blockingWaitings[Object.keys(myClip.blockingWaitings)[1]].incidentId).toBe('di1');
});
test("set blocking waiting to Clip from MonoIncident belonging to CASI", function () {
  casi = new DC({
    html: "\n            <div id=\"my-root-div\">\n                <div id=\"di-container\"></div>\n            </div>",
    css: "",
    selector: '#casi-container',
    id: 'casi'
  });
  var di2 = new TestPlugin.MPInc({
    animatedAttrs: {
      alpha: 1
    }
  }, {
    selector: '#di-container',
    duration: 1000,
    id: 'di2'
  });
  casi.addIncident(di2, 1000);
  myClip.addIncident(casi, 0);
  myClip.stop();
  myClip.play(true);
  myClip.playableProgress(1100 / myClip.duration, 1100);
  expect(Object.keys(myClip.blockingWaitings).length).toBe(3);
  expect(myClip.blockingWaitings[Object.keys(myClip.blockingWaitings)[0]].description).toBe('Blocking-description');
  expect(myClip.blockingWaitings[Object.keys(myClip.blockingWaitings)[1]].description).toBe('Blocking-description');
  expect(myClip.blockingWaitings[Object.keys(myClip.blockingWaitings)[0]].incidentId).toBe('di1');
  expect(myClip.blockingWaitings[Object.keys(myClip.blockingWaitings)[1]].incidentId).toBe('di1');
  expect(myClip.blockingWaitings[Object.keys(myClip.blockingWaitings)[2]].description).toBe('Blocking-description');
  expect(myClip.blockingWaitings[Object.keys(myClip.blockingWaitings)[2]].incidentId).toBe('di2');
});
test("set blocking waiting to Clip from AudioPlayback belonging to CASI", function () {
  var myMPB = new TestPlugin.MPMediaPlayback({}, {
    id: 'media-playback',
    selector: "~#classic",
    duration: 2000
  });
  myClip.addIncident(myMPB, 2000);
  myClip.stop();
  myClip.play(true);
  myClip.playableProgress(2100 / myClip.duration, 2100);
  expect(Object.keys(myClip.blockingWaitings).length).toBe(2);
  expect(myClip.blockingWaitings[Object.keys(myClip.blockingWaitings)[1]].incidentId).toBe('media-playback');
});
test("transition Clip while on blocking state should remove all blocks", function () {
  myClip.stop();
  expect(Object.keys(myClip.blockingWaitings).length).toBe(0);
});
test("blocks while on transition should be ignored by Clip", function () {
  myClip.play(true);
  var journey = TimeCapsule.startJourney(myClip);
  journey.station(500);
  journey.station(1000);
  journey.station(1100);
  journey.station(1500);
  journey.station(2500);
  journey.destination();
  expect(Object.keys(myClip.blockingWaitings).length).toBe(0);
  expect(myClip.runTimeInfo.state).toBe("playing");
});
test("set block from ClipCopy should block the Clip as normal", function () {
  var CAClipIncKey = Object.keys(myClip.realClip.children.casi.leaf.children)[0];
  var cCopy = myClip.realClip.children.casi.leaf.children[CAClipIncKey].leaf.contexts['my-clip'];
  cCopy.setBlock();
  expect(Object.keys(myClip.blockingWaitings)).toEqual([cCopy.blockID]);
});
test("unblock from ClipCopy", function () {
  var CAClipIncKey = Object.keys(myClip.realClip.children.casi.leaf.children)[0];
  var cCopy = myClip.realClip.children.casi.leaf.children[CAClipIncKey].leaf.contexts['my-clip'];
  cCopy.unblock();
  expect(Object.keys(myClip.blockingWaitings).length).toBe(0);
});