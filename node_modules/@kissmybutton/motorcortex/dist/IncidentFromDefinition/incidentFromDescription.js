"use strict";

var Group = require('../BaseClasses/Group');

var ElementSplitter = require('../Splitters/ElementSplitter');

var ElementClipSplitter = require('../Splitters/ElementClipSplitter');

var incidentFromIngredients = require('./incidentFromIngredients');

var Channel = require('../Channels/Channel');
/**
 * Creates a real Incident (with all of its real tree) out of the Descriptive Incident.
 * @param {object} descriptiveIncident - the Descriptive Incident that defines the Incident
 * @param {contextData} - the context data (object containing id and actual context) to be used for real
 *      Incidents init
 * @param {boolean} audio - defaults to false. It defines whether the method is been used
 *      by a real Clip or the Audio clip
 * @returns {object} - the real Incident
 **/


function incidentFromDescription(descriptiveIncident, contextData) {
  var audio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  /*
  RULES:
  - Clips can only have selectors (and not hosts) as they participate on a Desc. Tree
      and thus they are Clips As Incidents. The DescriptiveClips are treated a bit
      different compared to the rest of the Incidents as they copy all of the
      Description channels and lanes
  - Descriptive Incidents can either have or not have selectors
  - Descriptive Compos always have selectors
   All Incidents of the tree, no matter their type have the static properties:
  - Incident (which is the Incident class they need to initialise)
  - plugin_npm_name (the plugin name they bolong to)
  - Channel (the Channel class to handle the instance)
  */

  /* check for the descriptive incident and audio compatibility. If audio is true then we're
      working on the audioClip and we need incidents that are at least "on" while if the audio==false
      and we are working on the real tree then we reject the cases that the incident is audio "only"
  */
  if (audio === true && descriptiveIncident.audio === "off" || audio === false && descriptiveIncident.audio === "only") {
    return null;
  }

  var incidentToReturn;

  if (Object.prototype.hasOwnProperty.call(descriptiveIncident.props, 'selector')) {
    if (audio === false && descriptiveIncident.props.selector.charAt(0) === '~' || audio === true && descriptiveIncident.props.selector.charAt(0) !== '~' && descriptiveIncident.constructor.isClip === false) {
      return null;
    }
  }

  if (descriptiveIncident.constructor.isClip === true) {
    if (Object.prototype.hasOwnProperty.call(descriptiveIncident.props, 'selector') && audio === false) {
      incidentToReturn = new ElementClipSplitter(descriptiveIncident, contextData);
      incidentToReturn.plugin_channel_class = Channel;
    } else {
      if (audio === true) {
        return descriptiveIncident.audioClip;
      } else {
        return descriptiveIncident.realClip;
      }
    }
  } else if (descriptiveIncident.constructor.Incident === Group) {
    incidentToReturn = incidentFromIngredients({
      id: descriptiveIncident.id,
      attrs: descriptiveIncident.attrs,
      props: descriptiveIncident.props,
      Incident: descriptiveIncident.constructor.Incident,
      plugin_npm_name: descriptiveIncident.constructor.plugin_npm_name,
      Channel: descriptiveIncident.constructor.Channel,
      DescriptiveIncident: descriptiveIncident
    });

    for (var incId in descriptiveIncident.children) {
      var childIncident = incidentFromDescription(descriptiveIncident.children[incId].leaf, contextData);

      if (childIncident === null) {
        continue;
      }

      incidentToReturn.addChild(childIncident, descriptiveIncident.children[incId].position);
    }
  } else {
    // if it is an Incident that extends the Incident (not a Group) then
    // we should anaylse it to its element/attribute Incidents starting from
    // the elements, that's why we create an ElementSplitter. It is our
    // starting point to which the Incident will be analysed to its
    // element/attributes children.
    incidentToReturn = new ElementSplitter(descriptiveIncident, contextData);
  }

  return incidentToReturn;
}

module.exports = incidentFromDescription;