"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }

function _getDecoratorsApi() { _getDecoratorsApi = function _getDecoratorsApi() { return api; }; var api = { elementsDefinitionOrder: [["method"], ["field"]], initializeInstanceElements: function initializeInstanceElements(O, elements) { ["method", "field"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === "own") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function initializeClassElements(F, elements) { var proto = F.prototype; ["method", "field"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === "static" || placement === "prototype")) { var receiver = placement === "static" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function defineClassElement(receiver, element) { var descriptor = element.descriptor; if (element.kind === "field") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function decorateClass(elements, decorators) { var newElements = []; var finishers = []; var placements = { "static": [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function addElementPlacement(element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError("Duplicated element (" + element.key + ")"); } keys.push(element.key); }, decorateElement: function decorateElement(element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function decorateConstructor(elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError("Duplicated element (" + elements[j].key + ")"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function fromElementDescriptor(element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: "Descriptor", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === "field") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function toElementDescriptors(elementObjects) { if (elementObjects === undefined) return; return _toArray(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, "finisher", "An element descriptor"); this.disallowProperty(elementObject, "extras", "An element descriptor"); return element; }, this); }, toElementDescriptor: function toElementDescriptor(elementObject) { var kind = String(elementObject.kind); if (kind !== "method" && kind !== "field") { throw new TypeError('An element descriptor\'s .kind property must be either "method" or' + ' "field", but a decorator created an element descriptor with' + ' .kind "' + kind + '"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== "static" && placement !== "prototype" && placement !== "own") { throw new TypeError('An element descriptor\'s .placement property must be one of "static",' + ' "prototype" or "own", but a decorator created an element descriptor' + ' with .placement "' + placement + '"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, "elements", "An element descriptor"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== "field") { this.disallowProperty(elementObject, "initializer", "A method descriptor"); } else { this.disallowProperty(descriptor, "get", "The property descriptor of a field descriptor"); this.disallowProperty(descriptor, "set", "The property descriptor of a field descriptor"); this.disallowProperty(descriptor, "value", "The property descriptor of a field descriptor"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function toElementFinisherExtras(elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, "finisher"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function fromClassDescriptor(elements) { var obj = { kind: "class", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: "Descriptor", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function toClassDescriptor(obj) { var kind = String(obj.kind); if (kind !== "class") { throw new TypeError('A class descriptor\'s .kind property must be "class", but a decorator' + ' created a class descriptor with .kind "' + kind + '"'); } this.disallowProperty(obj, "key", "A class descriptor"); this.disallowProperty(obj, "placement", "A class descriptor"); this.disallowProperty(obj, "descriptor", "A class descriptor"); this.disallowProperty(obj, "initializer", "A class descriptor"); this.disallowProperty(obj, "extras", "A class descriptor"); var finisher = _optionalCallableProperty(obj, "finisher"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function runClassFinishers(constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== "function") { throw new TypeError("Finishers must return a constructor."); } constructor = newConstructor; } } return constructor; }, disallowProperty: function disallowProperty(obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + " can't have a ." + name + " property."); } } }; return api; }

function _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === "method") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === "get") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === "set") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === "field") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === "field" ? "field" : "method", key: key, placement: def["static"] ? "static" : def.kind === "field" ? "own" : "prototype", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === "field") element.initializer = def.value; return element; }

function _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }

function _coalesceClassElements(elements) { var newElements = []; var isSameElement = function isSameElement(other) { return other.kind === "method" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === "method" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError("Duplicated methods (" + element.key + ") can't be decorated."); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError("Decorators can't be placed on different accessors with for " + "the same property (" + element.key + ")."); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }

function _hasDecorators(element) { return element.decorators && element.decorators.length; }

function _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }

function _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== "function") { throw new TypeError("Expected '" + name + "' to be a function"); } return value; }

function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }

function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var Helper = require('../_coreUtils/Helper');

var helper = new Helper();

var Channel = require('../Channels/Channel');

var getIncidentsByChannel = require('../_decorators/getIncidentsByChannel');
/* @handleResize is missing from Incident. The reason is that when the
ExtendableClip asks for the under-resize candidates via the "checkResize" pipe
message the message will never be handled by an Incident directly but rather via
its corresponding ElementSplitter
*/


var setBlock = require('./decorators/block');

var unblock = require('./decorators/unblock');
/*
dna:
- originalId
- context
*/


var MonoIncident = _decorate(null, function (_initialize) {
  var MonoIncident = function MonoIncident() {
    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var dna = arguments.length > 2 ? arguments[2] : undefined;

    _classCallCheck(this, MonoIncident);

    _initialize(this);

    // super(props);
    this.attrs = attrs;
    this.props = props;
    this.dna = dna;
    this.context = dna.context;
    this.mcid = dna.mcid;
    this.id = props.id || helper.getAnId();
    this.modelId = props.modelId; // this parameter is initialised to false. Once the onGetContext method gets invoked this parameter
    // is set to true so we prevent multiple executions of the onGetContext method

    this.gotContext = false;
    /*
    these are the default values that define channeling for the default Incidents. These values get ovewriden through
    the loadPlugin method of MC with the values found on the main.js file of the plugin
    */

    this.plugin_channel_class = Channel;
    this.mc_plugin_npm_name = "motor-cortex-js";

    if (Object.prototype.hasOwnProperty.call(props, "plugin_channel_class")) {
      this.plugin_channel_class = props.plugin_channel_class;
    }

    if (Object.prototype.hasOwnProperty.call(props, "mc_plugin_npm_name")) {
      this.mc_plugin_npm_name = props.mc_plugin_npm_name;
    }

    this.hasIncidents = false;
    /*
    initialValues is an object holding the automatically computed initial values of the animatedAttrs
    (if any). The initialValues are calculated by the AttributesChannel (only Incidents belonging to
    an AttributesChannel have initialValues).
    The keys set of this object is identical to the object attrs.animatedAttrs
    The only thing the generic AttributesChannel can't calculate is the initial value of an animated attr
    of a specific element when there are no other Incidents entered on its lanes yet. These values are
    the "scratchValues" and they are strongly dependend on the nature of the lib. E.g. for a CSS animation
    what we are looking for can be found on the computedStyle.
    The initialValues are the values that are actually going to be used by
    the MonoIncident in the real execution of them
    */

    this.initialValues = {};
    /*
    The initial values defined by the user via the initialValues key on the
    attributes (if present)
    */

    this.userDefinedInitialValues = attrs.initialValues || {};
    /*
    The initialValues of the Incident as passed by the Attribute Channel.
    These values are been altered by the userDefinedInitialValues (if any)
    but we need them for passing them on other Incidents on edit and delete operations
    */

    this.pureInitialValues = null;
    /**
     * @member {boolean} - if autoGenerated is set to true, it means that this MonoIncident has been auto-generated by its parent on initialisation.
     * This happens when plugins export Incidents that on initialisation they automatically create other incidents and automatically put them
     * on specific points on their timeline.
     */

    this.autoGenerated = false;
    this.onInitialise(attrs, props);
  };

  return {
    F: MonoIncident,
    d: [{
      kind: "get",
      key: "selector",
      value: function selector() {
        return this.props.selector;
      }
      /* shortcuts for attrs.attrs and attrs.animatedAttrs */

    }, {
      kind: "get",
      key: "animAttributes",
      value: function animAttributes() {
        return this.attrs.animatedAttrs;
      }
    }, {
      kind: "set",
      key: "animAttributes",
      value: function animAttributes(value) {
        this.attrs.animatedAttrs[this.attributeKey] = value;
      }
      /**
      This method shoudl be overwritten by the Incidents of the plugins. The method returns
      the initial value that the element of it has as the library calculates / defines them. The
      returned value represents the very initial value of the element's attribute before
      any Incident that alters it gets added.
       @returns {mixed} - the initial value of the element's attribute just when the HTML & CSS
      of the Clip gets rendered
      */

    }, {
      kind: "method",
      key: "getScratchValue",
      value: function getScratchValue() {
        return 0;
      }
    }, {
      kind: "get",
      key: "element",
      value: function element() {
        if (this.contex === null) {
          return [];
        }

        if (this.context.getElementByMCID) {
          return this.context.getElementByMCID(this.mcid);
        }

        return this.context.getElements(this.selector)[0];
      }
    }, {
      kind: "get",
      key: "attributeKey",
      value: function attributeKey() {
        return Object.keys(this.attrs.animatedAttrs)[0];
      }
    }, {
      kind: "get",
      key: "targetValue",
      value: function targetValue() {
        return this.animAttributes[this.attributeKey];
      }
    }, {
      kind: "method",
      key: "getElementAttribute",
      value: function getElementAttribute(attr) {
        return this.element.getAttribute(attr);
      }
    }, {
      kind: "method",
      decorators: [getIncidentsByChannel],
      key: "getIncidentsByChannel",
      value: function getIncidentsByChannel() {}
    }, {
      kind: "method",
      key: "hasUserDefinedInitialValue",
      value: function hasUserDefinedInitialValue() {
        if (Object.prototype.hasOwnProperty.call(this.userDefinedInitialValues, this.attributeKey)) {
          return true;
        }

        return false;
      }
    }, {
      kind: "method",
      key: "setInitialValue",
      value: function setInitialValue(value) {
        var storePure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        if (storePure === true) {
          this.pureInitialValues = JSON.parse(JSON.stringify(value)); // keep a copy of the
          // passed initial values
        }

        if (!this.hasUserDefinedInitialValue()) {
          this.initialValues[this.attributeKey] = value;
          return;
        }

        if (_typeof(this.targetValue) === "object") {
          // if it is a combo attribute
          for (var key in this.userDefinedInitialValues[this.attributeKey]) {
            value[key] = this.userDefinedInitialValues[this.attributeKey][key];
          }

          this.initialValues[this.attributeKey] = value;
        } else {
          this.initialValues[this.attributeKey] = this.userDefinedInitialValues[this.attributeKey];
        }
      }
    }, {
      kind: "get",
      key: "initialValue",
      value: function initialValue() {
        return this.initialValues[this.attributeKey];
      }
    }, {
      kind: "method",
      key: "getInitialValue",
      value: function getInitialValue() {
        return this.initialValues[this.attributeKey];
      }
    }, {
      kind: "method",
      key: "_onGetContextOnce",
      value: function _onGetContextOnce() {
        // if the MonoIncident belongs to a fragmented context there absolutely
        // no reason to run the getContext method of it
        try {
          if (this.context.fragment === true) {
            return;
          }

          if (!this.gotContext) {
            this.onGetContext();
            this.gotContext = true;
          }
        } catch (e) {
          console.log(e);
          console.log(this.mcid); // console.log(this.context);
        }
      }
    }, {
      kind: "method",
      key: "onGetContext",
      value: function onGetContext() {
        helper.info('Overwritte the "onGetContext" method with the code you want to get executed', 'info');
      }
    }, {
      kind: "method",
      key: "lastWish",
      value: function lastWish() {}
    }, {
      kind: "method",
      key: "onInitialise",
      value: function onInitialise() {
        helper.info('Overwritte the "onInialise" method with the code you want to get executed', 'info');
      }
      /**
       * Method called on progress of the timed incident.
       * @param {float} fraction - a number from 0 to 1 representing the fraction of duration covered
       * @param {int} milliseconds - the number of milliseconds passed from start of the incident
       */

    }, {
      kind: "method",
      key: "onProgress",
      value: function onProgress(fraction, milliseconds) {// eslint-disable-line no-unused-vars
      }
    }, {
      kind: "method",
      decorators: [setBlock],
      key: "setBlock",
      value: function setBlock() {}
    }, {
      kind: "method",
      decorators: [unblock],
      key: "unblock",
      value: function unblock() {}
    }]
  };
});

module.exports = MonoIncident;