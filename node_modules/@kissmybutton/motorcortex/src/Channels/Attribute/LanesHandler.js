const _filter = require('../../../lodash-custom-build/modularize/lodash.filter/index');
const _sortBy = require('../../../lodash-custom-build/modularize/lodash.sortby/index');
const _findIndex = require('../../../lodash-custom-build/modularize/lodash.findindex/index');

const Helper = require('../../_coreUtils/Helper');
const helper = new Helper({ logLevel: 4 });

const Collection = require('./helpers/Collection');
const SandboxLanes = require('./helpers/SandboxLanes');
const SandboxCollection = require('./helpers/SandboxCollection');
const SandboxIncidentsById = require('./helpers/SandboxIncidentsById');

const setInitialValueForCombo = require('./helpers/ComboAttrsCascading');

class LanesHandler {
    constructor(props = {}) {
        /*
         * Keeps the lanes of the Channel in the form:
         * {
         *  <motorcortex-id>_<attribute>: [
         *      {
         *          id: the id of the Incident
         *          millisecond: the millisecond of the channel this Animation (that affects the selector/attribute pair) runs
         *      }
         *  ]
         * }
         /** @type {{}}
         */
        this.lanes = new Collection({});
        if (props.lanes) {
            this.lanes = props.lanes;
        }

        this.comboAttributes = {};
        if (props.comboAttributes != null) {
            this.comboAttributes = props.comboAttributes;
        }

        this.runTimeInfo = props.runTimeInfo;

        /*
        Keeps an indexing of the lanes each Animation belongs to. The form is the following:
        belongingLaneKeysByAnimationId: {
            <animation_id>: [laneKey1, laneKey2, ...],
            <animation_id>: [laneKey2, laneKey3, ...],
            ...
        }
         */
        this.belongingLaneKeysByAnimationId = new Collection({});
        if (props.belongingLaneKeysByAnimationId) {
            this.belongingLaneKeysByAnimationId = props.belongingLaneKeysByAnimationId;
        }

        /*
        keeps all Incidents (that appear on the lanes) mapped on a key - value pair
        object on which the keys are the ids and the values the corresponding Incidents.
        The Incidents of this object are ContextAwareIncidents
        */
        this.incidentsById = new Collection({});
        if (props.incidentsById) {
            this.incidentsById = props.incidentsById;
        }
    }

    /**
     * This method resizes all the lanes of the Lanes Handler by the durationFraction provided.
     * No checks are performed.
     * This method is been invoked in cases where a full Clip gets resized, so no conflict checks need to
     * run.
     * @param {float} durationFration: the fraction between the new duration and the current
     */
    _resize(durationFraction) {
        const keys = this.lanes._keys();

        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            const theLane = this.lanes._get(key);
            for (let i = 0; i < theLane.length; i++) {
                theLane[i].millisecond = theLane[i].millisecond * durationFraction;
            }
        }
    }


    /**
     * it creates a new LanesHandler that acts as a sanbox for testing changes
     */
    createTestLanesSanbox() {
        const props = {
            lanes: new SandboxLanes(this.lanes._export()),
            belongingLaneKeysByAnimationId: new SandboxCollection(this.belongingLaneKeysByAnimationId._export()),
            incidentsById: new SandboxIncidentsById(this.incidentsById._export())
        }

        if (this.comboAttributes) {
            props.comboAttributes = this.comboAttributes;
        }

        return new LanesHandler(props);
    }

    getLanesCopy(lane) {
        let laneToReturn = [];
        for (let i = 0; i < lane.length; i++) {
            laneToReturn.push({
                id: lane[i].id,
                millisecond: lane[i].millisecond * 1
            });
        }
        return laneToReturn;
    }

    getLaneElementsClone(laneElement) {
        return {
            id: laneElement.id,
            millisecond: laneElement.millisecond * 1
        }
    }

    applySandboxChanges(SanboxObject) {
        this.lanes = new Collection(SanboxObject.lanes._export());

        this.belongingLaneKeysByAnimationId = new Collection(SanboxObject.belongingLaneKeysByAnimationId._export());
        this.incidentsById = new Collection(SanboxObject.incidentsById._export());
    }


    getLane(mcid, attr) {
        return this.lanes._get(helper.getLaneKey(mcid, attr));
    }


    /**
     * return true if lane exists or false otherwise
     * @param {String} mcid
     * @param {String} attr
     * @param {boolean} ifNotCreateIt - if is set to true and the lane doesn't exist it creates it but still returning false
     */
    laneExists(mcid, attr, ifNotCreateIt = false) {
        let laneKey = helper.getLaneKey(mcid, attr);
        if (!this.lanes._hasOwnProperty(laneKey)) {
            if (ifNotCreateIt) {
                this.lanes._set(laneKey, []);
            }
            return false;
        }
        else {
            return true;
        }
    }

    /**
     * @param {Object} newAnim - an object of the form of a lane item (with keys "millisecond" and "incident"
     * @param {string} mcid
     * @param {String} attr
     * @param {array} excludeIdsFromCheck - optional. If exists it excludes all the ids of this array from check. This
     *  parameter has been added for the edit checks where an animation might overlap another animation that participates on
     *  the move, something that should not happen as the edited animations pre-existed without conflicts and the move of all
     *  of them together guarantees that there is going to be no conflict between them even after the edit
     * @param {int} testDuration - optional. This parameter is used when the channel needs to addcheck overlaps after duration
     *  edits, so the testDuration is passed (we don't want to polute the original animation object as it refers to the real one)
     * @retuns {array} - a list of all overlapping animations of the lane
     */
    getOverlappingAnims(newAnim, mcid, attr, excludeIdsFromCheck = [], testDuration = null) {
        const that = this;
        let overlappingAnims = _filter(this.lanes._get(helper.getLaneKey(mcid, attr)), function (existingAnim) {
            let durationToUseOnChecks = newAnim.incident.duration;
            if (testDuration != null) {
                durationToUseOnChecks = testDuration;
            }

            return (
                existingAnim.id != newAnim.incident.id &&
                excludeIdsFromCheck.indexOf(existingAnim.id) < 0 && (
                    // existing anim starts within the new anim's extend
                    (existingAnim.millisecond >= newAnim.millisecond &&
                        existingAnim.millisecond < durationToUseOnChecks + newAnim.millisecond)
                    // or ends within the new anim's extend
                    ||
                    (existingAnim.millisecond + that.incidentsById._get(existingAnim.id).duration > newAnim.millisecond &&
                        existingAnim.millisecond + that.incidentsById._get(existingAnim.id).duration <= durationToUseOnChecks + newAnim.millisecond)
                    // or it starts before and ends after the new anim's extend
                    ||
                    (existingAnim.millisecond < newAnim.millisecond &&
                        existingAnim.millisecond + that.incidentsById._get(existingAnim.id).duration > durationToUseOnChecks + newAnim.millisecond)
                ));
        });

        return overlappingAnims;
    }

    /**
     * it justs adds the lane item to the lane and adjusts the initial values of the Anims in sequence
     * No checks are performed, just execution.
     * @param {String} mcid
     * @param {String} attr
     * @param {int} millisecond
     * @param {Object} incident
     */
    addElementToLane(mcid, attr, millisecond, incident) {
        const laneKey = helper.getLaneKey(mcid, attr);

        this.incidentsById._set(incident.id, incident);
        const laneElement = {
            millisecond: millisecond,
            id: incident.id
        };

        this.laneExists(mcid, attr, true);
        let theLane = this.lanes._get(laneKey);

        theLane.push(laneElement);
        theLane = _sortBy(theLane, ['millisecond']);
        this.lanes._set(laneKey, theLane);

        // indexing stuff
        if (!this.belongingLaneKeysByAnimationId._hasOwnProperty(incident.id)) {
            this.belongingLaneKeysByAnimationId._set(incident.id, []);
        }
        this.belongingLaneKeysByAnimationId._get(incident.id).push(
            laneKey
        );
        // indexing
        const newAnimsIndex = _findIndex(theLane, function (item) {
            return item.id === incident.id;
        });


        // helper.log(newAnimsIndex);
        // step 1: set the intial values of the new Animation
        if (newAnimsIndex === 0) { // if the newly entered animation is the first of the lane
            if (theLane.length > 1) { // and it has other animations too
                incident.setInitialValue(this.incidentsById._get(theLane[1].id).pureInitialValues);
            }
            else {
                incident.setInitialValue();
            }
        }
        else {
            incident.setInitialValue(this.incidentsById._get(theLane[newAnimsIndex - 1].id).animatedAttributeValue);
        }

        /* if the attribute of the lane is a compo attribute */
        if (Object.prototype.hasOwnProperty.call(this.comboAttributes, attr)) {
            const incidentInitialValues = incident.initialValue;
            setInitialValueForCombo(theLane, this.incidentsById, incidentInitialValues, newAnimsIndex);
        }

        // step 2: set the inital values of the following Animation (if any).
        if (newAnimsIndex + 1 < theLane.length) {
            this.incidentsById._get(theLane[newAnimsIndex + 1].id).setInitialValue(incident.animatedAttributeValue);
            if (this.incidentsById._get(theLane[newAnimsIndex + 1].id).gotContext) {
                this.incidentsById._get(theLane[newAnimsIndex + 1].id).lastWish();
                this.incidentsById._get(theLane[newAnimsIndex + 1].id).onGetContext();
            }
        }
    }


    /**
     * it justs updates the lane
     * No checks are performed, just execution
     * @param {array} affectedAnimationsIds
     * @param {int} millisecondDelta
     */
    updateLane(affectedAnimationsIds, millisecondsDelta) {
        // first we group the affected animations by lanes
        let affectedLanes = {};
        const that = this;
        for (let i = 0; i < affectedAnimationsIds.length; i++) {
            const belongingLanes = this.belongingLaneKeysByAnimationId._get(affectedAnimationsIds[i]);
            for (let j = 0; j < belongingLanes.length; j++) {
                const laneKey = belongingLanes[j];
                if (!Object.prototype.hasOwnProperty.call(affectedLanes, laneKey)) {
                    affectedLanes[laneKey] = {
                        animations: [],
                        lane: that.lanes._get(laneKey),
                        laneData: helper.getMCIDandAttrOutOfLaneKey(belongingLanes[j])
                    }
                }
                affectedLanes[laneKey].animations.push(affectedAnimationsIds[i]);
            }
        }

        // for each of the affected lanes
        for (let laneKey in affectedLanes) {
            let affectedLane = affectedLanes[laneKey];
            let lane = affectedLane.lane;
            const laneData = affectedLane.laneData;
            const laneBeforeEdit = _sortBy(this.getLanesCopy(lane), ['millisecond']);
            const isComboAttr = Object.prototype.hasOwnProperty.call(this.comboAttributes, laneData.attribute);
            // edit lane items millisecond
            for (let k = 0; k < lane.length; k++) {
                if (affectedLane.animations.indexOf(lane[k].id) >= 0) {
                    lane[k].millisecond += millisecondsDelta;
                }
            } // end for searching for the animations within the lane

            let sortedLane = _sortBy(lane, ['millisecond']);
            this.lanes._set(laneKey, sortedLane);
            lane = sortedLane;

            for (let i = 0; i < affectedLane.animations.length; i++) {
                let animationToCheck = affectedLane.animations[i];
                const animationIndexBeforeEdit = _findIndex(laneBeforeEdit, function (item) {
                    return item.id === animationToCheck;
                });

                const animationIndexAfterEdit = _findIndex(lane, function (item) {
                    return item.id === animationToCheck;
                });

                const animation = this.incidentsById._get(lane[animationIndexAfterEdit].id);

                if (animationIndexBeforeEdit !== animationIndexAfterEdit || animationIndexAfterEdit > 1) {
                    if (animationIndexBeforeEdit + 1 < lane.length) { // if the animation was not the last animation on the lane before the edit
                        // we should take care of the initial values of the animation's previous successor
                        if (animationIndexBeforeEdit === 0) { // if the edited animation was the first one before the edit
                            // pass its initial values to its previous successor as its new initial values
                            if (isComboAttr) {
                                setInitialValueForCombo(lane, this.incidentsById, animation.pureInitialValues, 0, true);
                            }
                            else {
                                this.incidentsById._get(laneBeforeEdit[1].id).setInitialValue(animation.pureInitialValues);
                                this.incidentsById._get(laneBeforeEdit[1].id).onGetContext();
                            }
                        }
                        else { // else if the edited animation was not the first one before the edit
                            // meaning its previous successor is not the first one on the lane after the edit
                            // just grab the target value of the new previous animation of the animation's previous successor and set it as initial value
                            if (isComboAttr) {
                                const indexToAffect = animationIndexAfterEdit > animationIndexBeforeEdit ? animationIndexBeforeEdit : animationIndexAfterEdit;
                                setInitialValueForCombo(lane, this.incidentsById, this.incidentsById._get(laneBeforeEdit[animationIndexBeforeEdit - 1].id).animatedAttributeValue, indexToAffect, true);
                            }
                            else {
                                this.incidentsById._get(laneBeforeEdit[animationIndexBeforeEdit + 1].id).setInitialValue(this.incidentsById._get(laneBeforeEdit[animationIndexBeforeEdit - 1].id).animatedAttributeValue);
                                this.incidentsById._get(laneBeforeEdit[animationIndexBeforeEdit + 1].id).onGetContext();
                            }
                        }
                    }

                    // for the edited animation itself now:
                    if (animationIndexAfterEdit === 0) { // is it the first one (after edit)?
                        // get the initial values of the previously 0 indexed animation of the lane
                        if (isComboAttr) {
                            setInitialValueForCombo(lane, this.incidentsById, this.incidentsById._get(laneBeforeEdit[0].id).pureInitialValues, animationIndexAfterEdit, true);
                        }
                        else {
                            animation.setInitialValue(this.incidentsById._get(laneBeforeEdit[0].id).pureInitialValues);
                            animation.onGetContext();
                        }
                    }
                    else { // else if it is not the first one after editd
                        // just grab the target value of the previous animation on the updated lane and set it as its initial value
                        if (isComboAttr) {
                            setInitialValueForCombo(lane, this.incidentsById, this.incidentsById._get(lane[animationIndexAfterEdit - 1].id).animatedAttributeValue, animationIndexAfterEdit, true);
                        }
                        else {
                            animation.setInitialValue(this.incidentsById._get(lane[animationIndexAfterEdit - 1].id).animatedAttributeValue);
                            animation.onGetContext();
                        }
                    }

                    // for its new next animation (if it has one)
                    if (animationIndexAfterEdit + 1 < lane.length) {
                        // set its initial value to equal the target value of the edited animation
                        if (isComboAttr) {
                            setInitialValueForCombo(lane, this.incidentsById, animation.animatedAttributeValue, animationIndexAfterEdit + 1, true);
                        }
                        else {
                            this.incidentsById._get(lane[animationIndexAfterEdit + 1].id).setInitialValue(animation.animatedAttributeValue);
                            this.incidentsById._get(lane[animationIndexAfterEdit + 1].id).onGetContext();
                        }
                    }
                }

            }

        } // end for each of the belonging lanes of the animation

    }

    /**
     * removes the list of animations as provided
     * @param {array} removedAnimations - an array with the removed animations' ids
     */
    deleteAnimations(removedAnimations) {
        let affectedLanes = {};

        for (let i = 0; i < removedAnimations.length; i++) {
            const id = removedAnimations[i];
            // for each lane the affected Animation appears in
            const belongingLanes = this.belongingLaneKeysByAnimationId._get(id);
            for (let j = 0; j < belongingLanes.length; j++) {
                let lane = this.lanes._get(belongingLanes[j]);

                let animationIndexBeforeEdit = -1;
                for (let k = 0; k < lane.length; k++) {
                    if (lane[k].id === id) {
                        animationIndexBeforeEdit = k;
                        break;
                    }
                }

                // helper.log(animationIndexBeforeEdit);
                const animationToDelete = Object.assign({}, lane[animationIndexBeforeEdit]);
                const animationObjectToDelete = this.incidentsById._get(animationToDelete.id);
                const laneData = helper.getMCIDandAttrOutOfLaneKey(belongingLanes[j]);

                // gets the lane without the removed animation
                let newLane = [];
                for (let k = 0; k < lane.length; k++) {
                    if (lane[k].id != id) {
                        newLane.push(lane[k]);
                    }
                }
                this.lanes._set(belongingLanes[j], newLane);
                lane = this.lanes._get(belongingLanes[j]);

                if (lane.length === 0) {
                    // in case there are no more animations on the lane any more we reset
                    // the lane by running the progress(0,0), so that the affected elements
                    // will get back to their original attribute value
                    animationObjectToDelete.onProgress(0, 0);
                    this.lanes._delete(belongingLanes[j]);
                    if (Object.prototype.hasOwnProperty.call(affectedLanes, belongingLanes[j])) {
                        delete affectedLanes[belongingLanes[j]];
                    }
                }
                else {
                    affectedLanes[belongingLanes[j]] = helper.getMCIDandAttrOutOfLaneKey(belongingLanes[j]);
                    if (animationIndexBeforeEdit < lane.length && this.incidentsById._get(animationToDelete.id).pureInitialValues !== false) {
                        if (Object.prototype.hasOwnProperty.call(this.comboAttributes, laneData.attribute)) {
                            setInitialValueForCombo(lane, this.incidentsById, this.incidentsById._get(animationToDelete.id).pureInitialValues, animationIndexBeforeEdit, true);
                        }
                        else {
                            this.incidentsById._get(lane[animationIndexBeforeEdit].id).setInitialValue(this.incidentsById._get(animationToDelete.id).pureInitialValues);
                            this.incidentsById._get(lane[animationIndexBeforeEdit].id).onGetContext();
                        }
                    }
                }
            }
            this.belongingLaneKeysByAnimationId._delete(removedAnimations[i]);
        }
        return affectedLanes;
    }

    /**
     * This method is responsible for recalculating the scratch values of the first
     * Incident of each of the lanes of the LanesHandler according to the provided
     * context id
     **/
    recalcScratchValues(contextId) {
        const keys = this.lanes._keys();

        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            const theLane = this.lanes._get(key);
            if (theLane.length > 0) {
                const firstIncident = this.incidentsById._get(theLane[0].id);
                const newScratchValue = firstIncident.getScratchValue(contextId);
                const laneData = helper.getLaneDataFromLaneKey(key);
                if (Object.prototype.hasOwnProperty.call(this.comboAttributes, laneData.attribute)) { // if it is a combo
                    setInitialValueForCombo(theLane, this.incidentsById, newScratchValue, 0, true);
                }
                else { // else if it's not a combo attribute
                    firstIncident.setInitialValue(newScratchValue);
                }
                firstIncident.lastWish();
                firstIncident.onGetContext();
            }
        }
    }

}

module.exports = LanesHandler;
