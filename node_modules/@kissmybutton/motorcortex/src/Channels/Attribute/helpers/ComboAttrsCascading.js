/*
lane:
     * [
     *      {
     *          id: the id of the Incident
     *          millisecond: the millisecond of the channel this Animation (that affects the selector/attribute pair) runs
     *      }
     *  ]
*/

function updateFinalValues(affectedIncident, initialValues, originalFinalValues, finalValues) {
    // console.log(initialValues, originalFinalValues);
    let change = false;
    for (let key in initialValues) {
        if (!Object.prototype.hasOwnProperty.call(originalFinalValues, key)) {
            change = true;
            finalValues[key] = initialValues[key];
        }
    }
    affectedIncident.animatedAttributeValue = finalValues;
    return change;
}

/**
 * This function takes as input the index of the affected incident on the lane,
 * the lane and it re-calculates the
 * initial and final values of all the following incidents in the lane.
 * The function is used only in cases of combo attributes
 *
 * @param {boolean} store - if set to true the first Incident to be edited stores the
 *      initial values as its pureInitialValues
 **/
function setInitialValue(lane, incidentsById, newInitialValues, affectedIndex, store = false) {
    const affectedItem = lane[affectedIndex];
    const affectedIncident = incidentsById._get(affectedItem.id);
    affectedIncident.setInitialValue(newInitialValues, store);

    const change = updateFinalValues(affectedIncident, affectedIncident.initialValue, affectedIncident.originalAnimatedAttributeValue,
        JSON.parse(JSON.stringify(affectedIncident.animatedAttributeValue)));
    /// if the final values have changed according to the new initial values and there is
    // a following incident on the lane
    if (change) {
        affectedIncident.lastWish();
        affectedIncident.onGetContext();
    }

    if (change && affectedIndex < lane.length - 1) {
        setInitialValue(lane, incidentsById, affectedIncident.animatedAttributeValue, affectedIndex + 1, false);
    }
}

module.exports = setInitialValue;
