const Helper = require('../_coreUtils/Helper');
const helper = new Helper();

class Channel {
    constructor(props) {
        this.runTimeInfo = props.runTimeInfo;
        this.context = props.context;
        this.onInitialise();
        this.getIncidentById = props.getIncidentById;
        // this.type = "plain";
    }

    static get type() {
        return "plain";
    }

    onInitialise() {}

    _resize() {
        helper.log('Please overwite the _resize method of the Channel');
    }

    /**
     * @param {array} incidents - A collection of Incidents in the form:
     * {
     *  millisecond
     *  incident
     *  id
     * }
     * @returns either:
     *   {
     *       result:true,
     *       execute: // an array of functions that when executed it will add the Incidents on the Channels
     *   }
     *   or
     *   {
     *       result: false,
     *       errors
     *   }
     */
    addIncidents(incidents) {
        // first check the Incidents addition directly using the checkAddition method of the class
        const result = this.checkAddition(incidents);

        if (result.result === false) {
            return {
                result: false,
                errors: result.errors
            }
        }
        else {
            return {
                result: true,
                execute: result.execute
            }
        }
    }


    /**
     * It initially checks if the edit is allowed and if it is it retuns an array of executable functions
     * that apply the change
     * @param {array} incidents - the list of the incidents to edit in an array format [object, object, ...]
     * @param {int} millisecondsDelta - the milliseconds delta to apply to the incidents
     * @returns {object} -
     * either:
     {
        result: true,
        execute: // array of functions to be executed in order to apply the edit
     }
     or
     {
         result: false,
         errors: // an array including all the errors / conflicts found on edit
     }
    */
    editIncidents(incidents, millisecondsDelta) {
        // first check the Incidents addition directly using the checkAddition method of the class
        const result = this.checkEdit(incidents, millisecondsDelta);
        if (result.result === false) {
            return {
                result: false,
                errors: result.errors
            }
        }
        else {
            return {
                result: true,
                execute: result.execute
            }
        }
    }


    /**
     * Method to remove incidents
     * @param {array} incidents - the ids of the incidents to remove in an array format
     * @param {object} props
     * @retuns {object} -
     * either:
     {
        result: true,
        execute: // array of functions to be executed in order to apply the edit
     }
     or
     {
         result: false,
         errors: // an array including all the errors / conflicts found on edit
     }
    */
    removeIncidents(incidents, props = {}) {
        // first check the Incidents addition directly using the checkAddition method of the class
        const result = this.checkDelete(incidents, props);
        if (result.result === false) {
            return {
                result: false,
                errors: result.errors
            }
        }
        else {
            return {
                result: true,
                execute: result.execute
            }
        }
    }

    /**
     * This method is invoked whenever a CASI (the owner of the Channel) enters
     * the tree of another clip, so the scratch values of all first Incidents of
     * each channel should be recalculated based on the context. All Channels
     * that extend Channel can rewrite this method accordingly
     * @param {string} contextId - The id of the context of the Clip Copy according to which
     *      we are going to recalc the scratch values
     **/
    recalcScratchValues(contextId) {

    }


    /**
     * On this method the user defines the specific rules that apply on the plugin itself and on the Incidents of the plugin itself
     * The method should either return {result: true} or {result: false, errors:[{error-object}]}, where error-object has the structure:
     *  {
            incident: // reference to the Incident object that has bee discarded
            error: // text
        }
    * @param {array} incidents - a colleciton of all incidents to be added on the form:
    *
        {
            id
            millisecond
            incident
        }
    * @returns {object} -
    * either:
        {
            result:true,
            execute: // a function that when executed it will add the Incidents on the Channels
        }
        or
        {
            result: false,
            errors
        }
    */
    checkAddition(incidents) { // eslint-disable-line no-unused-vars
        return { result: true, execute: function () {} };
    }


    checkEdit(incidentsArray, millisecondsDelta) { // eslint-disable-line no-unused-vars
        return { result: true, execute: function () {} };
    }

    checkDelete(incidentIds) { // eslint-disable-line no-unused-vars
        return { result: true, execute: function () {} };
    }

    checkResizedIncidents(incidents) { // eslint-disable-line no-unused-vars
        return { result: true, execute: function () {} };
    }

    moveTo(from, to, contextId) {} // eslint-disable-line no-unused-vars


}

module.exports = Channel;
