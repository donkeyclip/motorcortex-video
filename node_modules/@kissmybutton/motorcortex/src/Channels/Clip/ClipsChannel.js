const Helper = require('../../_coreUtils/Helper');
const helper = new Helper();
const Channel = require('../Channel');
const _sortBy = require('../../../lodash-custom-build/modularize/lodash.sortby/index.js');
const _filter = require('../../../lodash-custom-build/modularize/lodash.filter/index.js');

class ClipChannel extends Channel {
    /*
    this.incidents is a collection of {incident, id, millisecond} objects always kept in order
        from lower to higher millisecond
    this.incidetnsById is an index of the incidents kept by id (this.incidents[incident-id] = Incident)
    */
    onInitialise() {
        this.incidents = [];
        this.incidentsById = {};
    }

    _incidentById(id) {
        return this.incidentsById[id];
    }


    _resize(durationFraction) {
        for (let i = 0; i < this.incidents.length; i++) {
            this.incidents[i].millisecond = this.incidents[i].millisecond * durationFraction;
        }
    }

    /**
    * @param {array} incidents - a colleciton of all incidents to be added on the form:
    *
        {
            id
            millisecond
            incident
        }
    * @returns {object} -
    * either:
        {
            result:true,
            execute: // a function that when executed it will add the Incidents on the Channels
        }
        or
        {
            result: false,
            errors
        }
    */
    checkAddition(incidents) {
        let errors = [];
        let candidateIncidentsById = {};
        let incidentsToConcat = [];

        for (let i = 0; i < incidents.length; i++) {
            candidateIncidentsById[incidents[i].id] = incidents[i].incident;
            incidentsToConcat.push({
                id: incidents[i].id,
                millisecond: incidents[i].millisecond
            });
            if (Object.prototype.hasOwnProperty.call(this.incidentsById, incidents[i].id)) {
                helper.error(`Incident with the id ${incidents[i].id} already exists. Addition is rejected.`);
                errors.push({
                    type: 'Already existing id',
                    meta: {
                        id: incidents[i].id
                    }
                });
            }
        }

        if (errors.length > 0) {
            return {
                result: false,
                errors: errors
            }
        }

        const that = this;
        const exec = function () {
            that.incidentsById = Object.assign(that.incidentsById, candidateIncidentsById);
            that.incidents = that.incidents.concat(incidentsToConcat);
            that.incidents = _sortBy(that.incidents, [
                laneItem => {
                    return laneItem.millisecond;
                }
            ]);
            for (let i = 0; i < incidents.length; i++) {
                that._incidentById(incidents[i].id)._onGetContextOnce(that.context);
            }
        }

        return { result: true, execute: exec };
    }


    /**
    @param {array} incidentsArray - A collection of the Incidetns to get edited in the form:
    {
        id
        millisecond
        incident
    }
    @param {int} millisecondsDelta- the delta of the star point of the provided incidents
    */
    checkEdit(incidentsArray, millisecondsDelta) {
        const that = this;
        const exec = function () {
            for (let i = 0; i < incidentsArray.length; i++) {
                for (let j = 0; j < that.incidents.length; j++) {
                    if (that.incidents[j].id === incidentsArray[i].id) {
                        that.incidents[j].millisecond += millisecondsDelta;
                        break;
                    }
                }
            }

            that.incidents = _sortBy(that.incidents, [
                laneItem => {
                    return laneItem.millisecond;
                }
            ]);

        }

        return { result: true, execute: exec };
    }

    checkDelete(incidentsArray) {
        const that = this;
        let incidentIds = [];
        for (let i = 0; i < incidentsArray.length; i++) {
            incidentIds.push(incidentsArray[i].id);
        }

        const exec = function () {
            let newIncidents = _filter(that.incidents, incident => {
                return incidentIds.indexOf(incident.id) === -1;
            });

            that.incidents = newIncidents;
            for (let i = 0; i < incidentIds.length; i++) {
                delete that.incidentsById[incidentIds[i]];
            }
        }

        return { result: true, execute: exec };
    }

    /**
     * @param {array} incidents - [{id, start, end, startDelta}]
     */
    checkResizedIncidents(incidents) {
        const that = this;
        const exec = function () {
            for (let i = 0; i < incidents.length; i++) {
                for (let j = 0; j < that.incidents.length; j++) {
                    if (that.incidents[j].id === incidents[i].id) {
                        that.incidents[j].millisecond += incidents[i].startDelta;
                        break;
                    }
                }
            }

            that.incidents = _sortBy(that.incidents, [
                laneItem => {
                    return laneItem.millisecond;
                }
            ]);
        }

        return { result: true, execute: exec };
    }

    /**
     @param {int} from - the millisecond to start from
     @param {int} to - the millisecond to go to
     @param {string} contextId - the context id to move
     @param {boolean} forceReset - set to true when we want full flash
     */
    moveTo(from, to, contextId, forceReset = false) {
        if (forceReset === true) {
            // incidents: [{id, millisecond}, {}, {}...]
            for (let i = 0; i < this.incidents.length; i++) {
                const laneItem = this.incidents[i];
                const incident = this._incidentById(laneItem.id);

                if (to < laneItem.millisecond) {
                    incident.onProgress(0, 0, contextId, true);
                }
                else if (to > laneItem.millisecond + incident.duration) {
                    incident.onProgress(1, incident.duration, contextId, true);
                }
                else {
                    incident.onProgress((to - laneItem.millisecond) / incident.duration, to - laneItem.millisecond, contextId, true);
                }
            }
        }
        else {
            const that = this;
            let participatingItems;
            if (to > from) {
                participatingItems = _filter(this.incidents, laneItem => {
                    return (
                        (laneItem.millisecond + that._incidentById(laneItem.id).duration >= from &&
                            laneItem.millisecond + that._incidentById(laneItem.id).duration <= to) || // it ends after from and before to millisecond
                        (that._incidentById(laneItem.id).duration + laneItem.millisecond >= to &&
                            laneItem.millisecond <= to)
                    ); // or it ends after the target millisecond but also starts before it
                });
            }
            else {
                participatingItems = _filter(this.incidents, laneItem => {
                    return (
                        (laneItem.millisecond + that._incidentById(laneItem.id).duration >= to &&
                            laneItem.millisecond + that._incidentById(laneItem.id).duration <= from) || // it ends after from and before to millisecond
                        (that._incidentById(laneItem.id).duration + laneItem.millisecond >= from &&
                            laneItem.millisecond <= from)
                    ); // or it ends after the target millisecond but also starts before it
                });
            }


            for (let i = 0; i < participatingItems.length; i++) {
                const laneItem = participatingItems[i];
                const contextAwareClipIncident = this._incidentById(laneItem.id);

                // onProgress(fraction, milliseconds, contextId, forceReset = false) {
                const overcameEnd = (to - laneItem.millisecond) / contextAwareClipIncident.duration >= 1;

                const fraction = overcameEnd ? 1 : (to - laneItem.millisecond) / contextAwareClipIncident.duration;
                const millisecond = overcameEnd ? contextAwareClipIncident.duration : to - laneItem.millisecond;

                contextAwareClipIncident.onProgress(fraction, millisecond, contextId, false);
            }
        }

        // this.runTimeInfo.currentMillisecond = to;
    }


}

module.exports = ClipChannel;
