const ClipsChannel = require('../Clip/ClipsChannel');
const _filter = require('../../../lodash-custom-build/modularize/lodash.filter/index.js');
const dataSeparator = "|||";
const Helper = require('../../_coreUtils/Helper');
const helper = new Helper();

class AudioPlaybackChannel extends ClipsChannel {
    constructor(props) {
        super(props);
        // keeps the list of the ids of MediaIncidents that are currently been played
        // in the form `${id}|||$[contextId}`
        this.playingIncidentsIds = [];
        // when the Channel's Clip enters the transitional state the Channel ignores
        // moveTos. When the transition ends though, no matter the currentMillisecond
        // its Clip was it should recalc which sources to play as if we were going from
        // 0 to the the target millisecond because of the different way the Playback operates
        // (it has no onProgress). For this, it's very important to store the information
        // that it entered the transitional state so on the next playing state moveTo
        // to force as from ms 0.
        this.transitioned = false;
        props.subscribe(
            helper.getAnId(), this._stateChange.bind(this), 0, 1, true
        );
    }

    _stateChange(ms, state) {
        if (state === "paused" || state === "idle" || state === "blocked") {
            this._stopPlayingIncidents();
            this.transitioned = true;
        }
    }

    _stopPlayingIncidents() {
        for (let i = 0; i < this.playingIncidentsIds.length; i++) {
            const incidentInfo = this.playingIncidentsIds[i].split(dataSeparator);
            this._incidentById(incidentInfo[0]).stop(incidentInfo[1]);
        }
        this.playingIncidentsIds = [];
    }

    /**
     @param {int} from - the millisecond to start from
     @param {int} to - the millisecond to go to
     @param {string} contextId - the context id to move
     @param {boolean} forceReset - set to true when we want full flash
     */
    moveTo(from, to, contextId, forceReset = false) {
        if (this.runTimeInfo.state === 'transitional' || forceReset === true) {
            this.transitioned = true;
            this._stopPlayingIncidents();

            for (let i = 0; i < this.incidents.length; i++) {
                const laneItem = this.incidents[i];
                const incident = this._incidentById(laneItem.id);

                if (to < laneItem.millisecond) {
                    incident.onProgress(0, 0, contextId, true);
                }
                else if (to > laneItem.millisecond + incident.duration) {
                    incident.onProgress(1, incident.duration, contextId, true);
                }
                else {
                    incident.onProgress((to - laneItem.millisecond) / incident.duration, to - laneItem.millisecond, contextId, true);
                }
            }
            return;
        }
        else {
            if (this.transitioned === true) {
                from = 0;
                this.transitioned = false;
            }
        }

        const that = this;
        const startingAnims = _filter(this.incidents, laneItem => {
            return (
                (laneItem.millisecond >= from && laneItem.millisecond < to) &&
                (laneItem.millisecond + that._incidentById(laneItem.id).duration > to)
            );
        });

        const finishingAnims = _filter(this.incidents, laneItem => {
            return (
                that._incidentById(laneItem.id).duration + laneItem.millisecond > from &&
                that._incidentById(laneItem.id).duration + laneItem.millisecond <= to
            ); // or it ends after the target millisecond but also starts before it
        });

        //console.log(this._incidentById);
        // console.log(from, to);
        // console.log(startingAnims);
        // console.log(finishingAnims);

        for (let i = 0; i < startingAnims.length; i++) {
            const laneItem = startingAnims[i];
            const MediaIncident = this._incidentById(laneItem.id);

            // onProgress(fraction, milliseconds, contextId, forceReset = false) {
            const overcameEnd = (to - laneItem.millisecond) / MediaIncident.duration >= 1;

            const fraction = overcameEnd ? 1 : (to - laneItem.millisecond) / MediaIncident.duration;
            const millisecond = overcameEnd ? MediaIncident.duration : to - laneItem.millisecond;

            const startAttempt = MediaIncident.play(fraction, millisecond, contextId);
            if (startAttempt === true) {
                this.playingIncidentsIds.push(`${laneItem.id}${dataSeparator}${contextId}`);
            }
        }

        for (let i = 0; i < finishingAnims.length; i++) {
            const laneItem = finishingAnims[i];
            const MediaIncident = this._incidentById(laneItem.id);

            MediaIncident.stop(contextId);

            var index = this.playingIncidentsIds.indexOf(`${laneItem.id}${dataSeparator}${contextId}`);
            if (index > -1) {
                this.playingIncidentsIds.splice(index, 1);
            }
        }

        this.runTimeInfo.currentMillisecond = to;
    }


}

module.exports = AudioPlaybackChannel;
