import audioPluginMain from './Audio/main';
import MediaPlayback from './BaseClasses/MediaPlayIncident';
import MonoIncident from './BaseClasses/MonoIncident';
import AttributeChannel from './Channels/Attribute/AttributeChannel';
import AudioPlaybackChannel from './Channels/Media/AudioPlaybackChannel';
import DOMClip from './Clip/DOMClip';
import ExtendableClip from './Clip/ExtendableClip';
import DescriptiveAudioClip from './DescriptiveIncidents/DescriptiveAudioClip';
import DescriptiveClip from './DescriptiveIncidents/DescriptiveClip';
import DescriptiveGroup from './DescriptiveIncidents/DescriptiveGroup';
import DescriptiveIncident from './DescriptiveIncidents/DescriptiveIncident';
import clipFromDefinition from './IncidentFromDefinition/clipFromDefinition';
import createValidator from './_coreUtils/customValidations';
import easings from './_coreUtils/easings';
import { Helper } from './_coreUtils/Helper';
import TimeCapsule from './_coreUtils/TimeCapsule';
const v = createValidator();

const helper = new Helper({ logLevel: 0 });

function checkPlugin(main) {
  if (Object.prototype.hasOwnProperty.call(main, 'default')) {
    main = main.default;
  }

  const plugin_name = main.npm_name;
  let check = true;

  if (!Object.prototype.hasOwnProperty.call(main, 'name')) {
    helper.error(`Warning on plugin ${plugin_name}. A plugin is always good to have its name on
        its main.js file, under the key "name". It's missing from this plugin`);
  }

  if (!Object.prototype.hasOwnProperty.call(main, 'incidents') && !Object.prototype.hasOwnProperty.call(main, 'Clip')) {
    helper.error(`Error on plugin ${plugin_name}. A plugin must expose at least one Incident or a Clip.
        Exposed plugin Incidents should be defined on the "incidents" key of the main.js file while Clips on the "Clip".`);
    check = false;
  }

  if (Object.prototype.hasOwnProperty.call(main, 'incidents') && !Array.isArray(main.incidents)) {
    helper.error(`Error on plugin ${plugin_name}. thePlugin exposed Incidents are defined on the "incidents" key of the main.js file in array format.
        Please refer to the documentation`);
    check = false;
  } else if (Object.prototype.hasOwnProperty.call(main, 'incidents')) {
    for (let i = 0; i < main.incidents.length; i++) {
      const exposedIncidentDefinition = main.incidents[i];

      if (typeof exposedIncidentDefinition.exportable === 'object') {
        if (Object.prototype.hasOwnProperty.call(exposedIncidentDefinition.exportable, 'default')) {
          exposedIncidentDefinition.exportable = exposedIncidentDefinition.exportable.default;
        }
      }

      if (
        !(exposedIncidentDefinition.exportable.prototype instanceof DescriptiveGroup) &&
        !(exposedIncidentDefinition.exportable.prototype instanceof DescriptiveClip) &&
        !(exposedIncidentDefinition.exportable.prototype instanceof MonoIncident) &&
        !(exposedIncidentDefinition.exportable.prototype instanceof MediaPlayback)
      ) {
        helper.error(`Error on plugin ${plugin_name}. Exportable Incidents by any plugin must extend one of the base classes provided by MotorCortex.
                ${exposedIncidentDefinition.exportable.constructor.name} doesn't.
                Please refer to documentation`);
        check = false;
      }

      if (!Object.prototype.hasOwnProperty.call(exposedIncidentDefinition, 'name')) {
        helper.error(`Error on plugin ${plugin_name}. Exportable Incidents by any plugin must have the "name" key which defines the name of the exported Incident.
                Please refer to documentation`);
        check = false;
      }

      if (!Object.prototype.hasOwnProperty.call(exposedIncidentDefinition, 'propTypes')) {
        helper.log(
          `Warning on plugin ${plugin_name}.
                It's always good for plugins to define the supported propTypes of their exposed Incidents' supported properties.
                ${exposedIncidentDefinition.exportable.constructor.name} doesn't.
                Please refer to documentation`,
          'warning'
        );
      }
    }
  }

  return check;
}

// plugin_name is the unique name of the plugin
export function loadPlugin(plugin) {
  if (Object.prototype.hasOwnProperty.call(plugin, 'default')) {
    plugin = plugin.default;
  }

  if (!Object.prototype.hasOwnProperty.call(plugin, 'npm_name')) {
    plugin.npm_name = `plugin_${new Date().getTime()}`;
  }

  if (!checkPlugin(plugin)) {
    return false;
  }

  // thePlugin is the plugin object which will hold on its keys
  // the names of the exposed Incidents of its. The keys of this object
  // are going to be identical with the names of the classes exposed
  const thePlugin = {};

  if (Object.prototype.hasOwnProperty.call(plugin, 'Clip')) {
    const DynamicDescriptiveClip = class extends DescriptiveClip {
      static Incident = plugin.Clip;

      static audio = plugin.audio ? plugin.audio : 'off';

      static customClip = true;
    };
    thePlugin.Clip = DynamicDescriptiveClip;
  }

  // if the plugin definition has compositeAttributes then we dynamically
  // create a new Channel class extending AttributeChannel setting the
  // composite Attributes on the fly. We can then use this Channel class
  // for all Incidents exposed by the plugin
  let AttributeChannelToUse = AttributeChannel;
  if (Object.prototype.hasOwnProperty.call(plugin, 'compositeAttributes')) {
    AttributeChannelToUse = class extends AttributeChannel {
      constructor(props) {
        props.comboAttributes = plugin.compositeAttributes;
        super(props);
      }
    };
  }

  // for each of the exposed Incidents
  if (Object.prototype.hasOwnProperty.call(plugin, 'incidents')) {
    for (let i = 0; i < plugin.incidents.length; i++) {
      const incidentClass = plugin.incidents[i].exportable;

      let DynamicDescriptiveIncident;
      // the exportable Incident can be either a Clip, a Compo or an Incident
      // if it is an Incident
      if (incidentClass.prototype instanceof MonoIncident) {
        DynamicDescriptiveIncident = class extends DescriptiveIncident {
          static Incident = incidentClass;

          static plugin_npm_name = plugin.npm_name;

          static plugin = plugin.name;

          static ClassName = plugin.incidents[i].name;

          static Channel = AttributeChannelToUse;

          static audio = plugin.audio ? plugin.audio : 'off';
        };
      } else if (incidentClass.prototype instanceof MediaPlayback) {
        DynamicDescriptiveIncident = class extends DescriptiveIncident {
          static Incident = incidentClass;

          static plugin_npm_name = '@kissmybutton/media-playback';

          static plugin = plugin.name;

          static ClassName = plugin.incidents[i].name;

          static Channel = AudioPlaybackChannel;

          static audio = plugin.audio ? plugin.audio : 'off';
        };
      } else if (incidentClass.prototype instanceof DescriptiveClip) {
        DynamicDescriptiveIncident = class extends incidentClass {
          // static Incident = incidentClass;
          static plugin = plugin.name;

          static ClassName = plugin.incidents[i].name;

          static audio = plugin.audio ? plugin.audio : 'on';
        };
      } else if (incidentClass.prototype instanceof DescriptiveGroup) {
        DynamicDescriptiveIncident = class extends incidentClass {
          // static Incident = incidentClass;
          static plugin = plugin.name;

          static ClassName = plugin.incidents[i].name;
        };
      }

      Object.defineProperty(thePlugin, plugin.incidents[i].name, {
        get() {
          // the getter will construct a wrapper class which on the constructor will instantiate an object of the
          // exposed class, set to it the plugin name and channel class parameters and return
          // it from the constructor
          class WrapperClass {
            constructor(attrs, props) {
              const instantiatedIncident = new DynamicDescriptiveIncident(attrs, props);

              if (Object.prototype.hasOwnProperty.call(plugin.incidents[i], 'attributesValidationRules')) {
                const validationRulesToUse = JSON.parse(JSON.stringify(plugin.incidents[i].attributesValidationRules));
                if (Object.prototype.hasOwnProperty.call(plugin.incidents[i].attributesValidationRules, 'animatedAttrs')) {
                  // make all initialValues optional and store it on the validationRulesToUse
                  validationRulesToUse.initialValues = helper.buildInitialValuesValidationRules(validationRulesToUse.animatedAttrs);
                }
                const validationResult = v.validate(attrs, validationRulesToUse);
                if (validationResult.length > 0) {
                  let errorMessage = `Error on plugin's "${plugin.npm_name}" "${plugin.incidents[i].name}" instantiation. Errors:`;
                  for (let j = 0; j < validationResult.length; j++) {
                    errorMessage += `\n - ${validationResult[j].message}. ${validationResult[j].actual} provided`;
                  }
                  console.error(errorMessage); // eslint-disable-line no-console
                  return {
                    result: false,
                    errors: validationResult
                  };
                } else {
                  instantiatedIncident.attrsValidationRules = plugin.incidents[i].attributesValidationRules;
                }
              } else {
                helper.warning(
                  `It's always good to provide attributesValidationRules to the exported incidents. ${plugin.npm_name}.${instantiatedIncident.constructor.name} doesn't provide it`
                );
              }
              return instantiatedIncident;
            }
          }
          return WrapperClass;
        }
      });
    }
  }

  return thePlugin;
}

const AudioPlugin = loadPlugin(audioPluginMain);

export const Clip = DescriptiveClip;
export const Group = DescriptiveGroup;
export const AudioClip = AudioPlugin.Clip;
export const { AudioPlayback } = AudioPlugin;

export const API = {
  MonoIncident,
  Group,
  Clip,
  AudioClip: DescriptiveAudioClip,
  MediaPlayback,
  ExtendableClip,
  DOMClip,
  easings,
  clipFromDefinition
};

export { TimeCapsule };

export default {
  API,
  Group,
  Clip,
  loadPlugin,
  AudioClip,
  AudioPlayback,
  AudioEffect: AudioPlugin.AudioEffect,
  TimeCapsule
};
