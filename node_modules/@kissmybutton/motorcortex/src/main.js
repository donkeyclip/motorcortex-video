const Validator = require("fastest-validator");

const DescriptiveIncident = require('./DescriptiveIncidents/DescriptiveIncident');
const DescriptiveGroup = require('./DescriptiveIncidents/DescriptiveGroup');
const DescriptiveClip = require('./DescriptiveIncidents/DescriptiveClip');
const DescriptiveAudioClip = require('./DescriptiveIncidents/DescriptiveAudioClip');
const MonoIncident = require('./BaseClasses/MonoIncident');
const MediaPlayback = require('./BaseClasses/MediaPlayIncident');
const AudioPlaybackChannel = require('./Channels/Media/AudioPlaybackChannel');
const ExtendableClip = require('./Clip/ExtendableClip');
const DOMClip = require('./Clip/DOMClip');

const AttributeChannel = require('./Channels/Attribute/AttributeChannel');

const TimeCapsule = require('./_coreUtils/TimeCapsule')

const Helper = require('./_coreUtils/Helper');
const helper = new Helper({ logLevel: 0 });

const checkPlugin = function (main) {
    if (Object.prototype.hasOwnProperty.call(main, "default")) {
        main = main.default;
    }

    const plugin_name = main.npm_name;
    let check = true;

    if (!Object.prototype.hasOwnProperty.call(main, "name")) {
        helper.error(`Warning on plugin ${plugin_name}. A plugin is always good to have its name on
        its main.js file, under the key "name". It's missing from this plugin`);
    }

    if (!Object.prototype.hasOwnProperty.call(main, "incidents") && !Object.prototype.hasOwnProperty.call(main, "Clip")) {
        helper.error(`Error on plugin ${plugin_name}. A plugin must expose at least one Incident or a Clip.
        Exposed plugin Incidents should be defined on the "incidents" key of the main.js file while Clips on the "Clip".`);
        check = false;
    }

    if (Object.prototype.hasOwnProperty.call(main, "incidents") && !helper.isArray(main.incidents)) {
        helper.error(`Error on plugin ${plugin_name}. thePlugin exposed Incidents are defined on the "incidents" key of the main.js file in array format.
        Please refer to the documentation`);
        check = false;
    }
    else if (Object.prototype.hasOwnProperty.call(main, "incidents")) {
        for (let i = 0; i < main.incidents.length; i++) {
            const exposedIncidentDefinition = main.incidents[i];

            if (typeof exposedIncidentDefinition.exportable === "object") {
                if (Object.prototype.hasOwnProperty.call(exposedIncidentDefinition.exportable, "default")) {
                    exposedIncidentDefinition.exportable = exposedIncidentDefinition.exportable.default;
                }
            }

            if (!(exposedIncidentDefinition.exportable.prototype instanceof DescriptiveGroup) &&
                !(exposedIncidentDefinition.exportable.prototype instanceof DescriptiveClip) &&
                !(exposedIncidentDefinition.exportable.prototype instanceof MonoIncident) &&
                !(exposedIncidentDefinition.exportable.prototype instanceof MediaPlayback)) {
                helper.error(`Error on plugin ${plugin_name}. Exportable Incidents by any plugin must extend one of the base classes provided by MotorCortex.
                ${exposedIncidentDefinition.exportable.constructor.name} doesn't.
                Please refer to documentation`);
                check = false;
            }

            if (!Object.prototype.hasOwnProperty.call(exposedIncidentDefinition, "name")) {
                helper.error(`Error on plugin ${plugin_name}. Exportable Incidents by any plugin must have the "name" key which defines the name of the exported Incident.
                Please refer to documentation`);
                check = false;
            }

            if (!Object.prototype.hasOwnProperty.call(exposedIncidentDefinition, "propTypes")) {
                helper.log(`Warning on plugin ${plugin_name}.
                It's always good for plugins to define the supported propTypes of their exposed Incidents' supported properties.
                ${exposedIncidentDefinition.exportable.constructor.name} doesn't.
                Please refer to documentation`, 'warning');
            }
        }
    }

    return check;
}

// plugin_name is the unique name of the plugin
function loadPlugin(plugin) {
    if (Object.prototype.hasOwnProperty.call(plugin, "default")) {
        plugin = plugin.default;
    }

    if (!Object.prototype.hasOwnProperty.call(plugin, "npm_name")) {
        plugin.npm_name = `plugin_${new Date().getTime()}`;
    }

    if (!checkPlugin(plugin)) {
        return false;
    }
    else {
        // thePlugin is the plugin object which will hold on its keys
        // the names of the exposed Incidents of its. The keys of this object
        // are going to be identical with the names of the classes exposed
        const thePlugin = {};

        if (Object.prototype.hasOwnProperty.call(plugin, "Clip")) {
            const DynamicDescriptiveClip = class extends DescriptiveClip {
                static Incident = plugin.Clip;
                static audio = plugin.audio ? plugin.audio : "off";
                static customClip = true;
            }
            thePlugin.Clip = DynamicDescriptiveClip;
        }

        // if the plugin definition has compositeAttributes then we dynamically
        // create a new Channel class extending AttributeChannel setting the
        // composite Attributes on the fly. We can then use this Channel class
        // for all Incidents exposed by the plugin
        let AttributeChannelToUse = AttributeChannel;
        if (Object.prototype.hasOwnProperty.call(plugin, "compositeAttributes")) {
            AttributeChannelToUse = class extends AttributeChannel {
                constructor(props) {
                    props.comboAttributes = plugin.compositeAttributes;
                    super(props);
                }
            }
        }

        // for each of the exposed Incidents
        if (Object.prototype.hasOwnProperty.call(plugin, "incidents")) {
            for (let i = 0; i < plugin.incidents.length; i++) {
                const incidentClass = plugin.incidents[i].exportable;

                let DynamicDescriptiveIncident;
                // the exportable Incident can be either a Clip, a Compo or an Incident
                // if it is an Incident
                if (incidentClass.prototype instanceof MonoIncident) {
                    DynamicDescriptiveIncident = class extends DescriptiveIncident {
                        static Incident = incidentClass;
                        static plugin_npm_name = plugin.npm_name;
                        static plugin = plugin.name;
                        static ClassName = plugin.incidents[i].name;
                        static Channel = AttributeChannelToUse;
                        static audio = plugin.audio ? plugin.audio : "off";
                    }
                } // if it is an Incident
                else if (incidentClass.prototype instanceof MediaPlayback) {
                    DynamicDescriptiveIncident = class extends DescriptiveIncident {
                        static Incident = incidentClass;
                        static plugin_npm_name = '@kissmybutton/media-playback';
                        static plugin = plugin.name;
                        static ClassName = plugin.incidents[i].name;
                        static Channel = AudioPlaybackChannel;
                        static audio = plugin.audio ? plugin.audio : "off";
                    }
                } // else if it is a Clip
                else if (incidentClass.prototype instanceof DescriptiveClip) {
                    DynamicDescriptiveIncident = class extends incidentClass {
                        // static Incident = incidentClass;
                        static plugin = plugin.name;
                        static ClassName = plugin.incidents[i].name;
                        static audio = plugin.audio ? plugin.audio : "on";
                    }
                }
                else if (incidentClass.prototype instanceof DescriptiveGroup) {
                    DynamicDescriptiveIncident = class extends incidentClass {
                        // static Incident = incidentClass;
                        static plugin = plugin.name;
                        static ClassName = plugin.incidents[i].name;
                    }
                }

                Object.defineProperty(thePlugin, plugin.incidents[i].name, {
                    get() {
                        // the getter will construct a wrapper class which on the constructor will instantiate an object of the
                        // exposed class, set to it the plugin name and channel class parameters and return
                        // it from the constructor
                        class WrapperClass {
                            constructor(attrs, props) {
                                const instantiatedIncident = new DynamicDescriptiveIncident(attrs, props);

                                if (Object.prototype.hasOwnProperty.call(plugin.incidents[i], "attributesValidationRules")) {
                                    const v = new Validator();
                                    const validationResult = v.validate(attrs, plugin.incidents[i].attributesValidationRules);
                                    if (validationResult.length > 0) {
                                        let errorMessage = `Error on plugin's "${plugin.npm_name}" "${plugin.incidents[i].name}" instantiation. Errors:`;
                                        for (let i = 0; i < validationResult.length; i++) {
                                            errorMessage += `\n - ${validationResult[i].message}. ${validationResult[i].actual} provided`;
                                        }
                                        console.error(errorMessage);
                                        return {
                                            result: false,
                                            errors: validationResult
                                        }
                                    }
                                }
                                else {
                                    helper.warning(`It's always good to provide attributesValidationRules to the exported incidents. ${plugin.npm_name}.${instantiatedIncident.constructor.name} doesn't provide it`)
                                }
                                return instantiatedIncident;
                            }
                        }
                        return WrapperClass;
                    }
                })
            }
        }

        return thePlugin;
    }

}

const audioPluginMain = require('./Audio/main');
const AudioPlugin = loadPlugin(audioPluginMain);

module.exports = {
    API: {
        MonoIncident: MonoIncident,
        Group: DescriptiveGroup,
        Clip: DescriptiveClip,
        AudioClip: DescriptiveAudioClip,
        MediaPlayback: MediaPlayback,
        ExtendableClip: ExtendableClip,
        DOMClip: DOMClip
    },
    Group: DescriptiveGroup,
    Clip: DescriptiveClip,
    loadPlugin: loadPlugin,
    AudioClip: AudioPlugin.Clip,
    AudioPlayback: AudioPlugin.AudioPlayback,
    AudioEffect: AudioPlugin.AudioEffect,
    TimeCapsule: TimeCapsule
}
