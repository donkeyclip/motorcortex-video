const Node = require('../Tree/Node');
const Channel = require('../Channels/Channel');
const handleResize = require('./decorators/handleResize');
const setBlock = require('./decorators/block');
const unblock = require('./decorators/unblock');

class Group extends Node {
    constructor(attrs, props) {
        super(props);

        this.mc_plugin_npm_name = 'motor-cortex-js';
        this.plugin_channel_class = Channel;

        this.hasIncidents = true;
        this.onGroupInitialise();

        this.calculatedDuration = 0;
    }


    onGroupInitialise() {
        // called when group gets initialised
    }

    handleAddIncident(target, payload) {
        if (this.id === target) {
            const incidentFromDescription = require('../IncidentFromDefinition/incidentFromDescription');
            const theIncident = incidentFromDescription(payload.incident, payload.contextData, payload.audio);
            // in the case that an audio clip tries to process an non-audio incident or
            // a non-audio incident tries to process an audio incident the result from incidentFromDescription is null
            // in such a case there should be no candidate return, so this.bypass()
            if (theIncident === null) {
                return this.bypass();
            }
            else {
                return theIncident;
            }
        }
        else {
            return this.bypass();
        }
    }

    handleMoveIncident(target, payload) {
        if (this.id === target) {
            const res = this.getLeafById(payload.incidentId, true);
            if (res === null) {
                return this.bypass();
            }
            return res;
        }
        else {
            return this.bypass();
        }
    }

    handleRemoveIncident(target, payload) {
        if (this.id === target) {
            const res = this.getLeafById(payload.incidentId, true);
            if (res === null) {
                return this.bypass();
            }
            return res;
        }
        else {
            return this.bypass();
        }
    }

    @handleResize
    handleResize() {}

    removeChild(id) {
        this.children[id].leaf.lastWish();
        super.removeChild(id);
    }


    /**
     * Returns an object that has the key of the npm plugin name the Channel of which manages the specific Incident
     * With the same logic all Incidents that belong to this Group as categorised by plugin / channel on the same object
     */
    getIncidentsByChannel(adjustMillisecond = 0, parentMillisecond = 0) {
        // initially it only puts itself onthe incidentsByPlugin array, exactly as the plain Incidents do
        let incidentsByPlugin = {};

        incidentsByPlugin['motor-cortex-js'] = [{
            millisecond: adjustMillisecond,
            parentMillisecond: parentMillisecond,
            incident: this,
            id: this.id
        }];

        // proceed to gather the contained incidents as well
        for (let childId in this.children) {
            const child = this.children[childId];
            const incidentsToAdd = child.leaf.getIncidentsByChannel(adjustMillisecond + child.position, adjustMillisecond);
            for (let key in incidentsToAdd) {
                if (Object.prototype.hasOwnProperty.call(incidentsByPlugin, key)) {
                    incidentsByPlugin[key] = incidentsByPlugin[key].concat(incidentsToAdd[key]);
                }
                else {
                    incidentsByPlugin[key] = incidentsToAdd[key];
                }
            }
        }
        return incidentsByPlugin;
    }


    lastWish() {
        for (let childId in this.children) {
            this.children[childId].leaf.lastWish();
        }
    }

    @setBlock
    setBlock() {}

    @unblock
    unblock() {}


}

module.exports = Group;
