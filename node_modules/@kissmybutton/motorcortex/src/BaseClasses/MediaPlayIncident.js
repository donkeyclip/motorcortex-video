const Helper = require('../_coreUtils/Helper');
const helper = new Helper();
const MediaChannel = require('../Channels/Media/AudioPlaybackChannel');
const getIncidentsByChannel = require('../_decorators/getIncidentsByChannel');
const setBlock = require('./decorators/block');
const unblock = require('./decorators/unblock');

/*
dna:
- originalId
- context
*/
class MediaPlay {
    constructor(attrs = {}, props = {}, dna) {
        // super(props);
        this.attrs = attrs;
        this.props = props;
        this.dna = dna;

        this.context = dna.context;
        this.mcid = dna.mcid;

        this.id = props.id || helper.getAnId();
        this.modelId = props.modelId;

        // this parameter is initialised to false. Once the onGetContext method gets invoked this parameter
        // is set to true so we prevent multiple executions of the onGetContext method
        this.gotContext = false;

        /*
        these are the default values that define channeling for the default Incidents. These values get ovewriden through
        the loadPlugin method of MC with the values found on the main.js file of the plugin
        */
        this.plugin_channel_class = MediaChannel;
        this.mc_plugin_npm_name = "motor-cortex-js-media-playback";
        if (Object.prototype.hasOwnProperty.call(props, "plugin_channel_class")) {
            this.plugin_channel_class = props.plugin_channel_class;
        }
        if (Object.prototype.hasOwnProperty.call(props, "mc_plugin_npm_name")) {
            this.mc_plugin_npm_name = props.mc_plugin_npm_name;
        }

        this.hasIncidents = false;

        /**
         * @member {boolean} - if autoGenerated is set to true, it means that this Incident has been auto-generated by its parent on initialisation.
         * This happens when plugins export Incidents that on initialisation they automatically create other incidents and automatically put them
         * on specific points on their timeline.
         */
        this.autoGenerated = false;

        this.onInitialise(attrs, props);
    }


    get selector() {
        return this.props.selector;
    }

    get element() {
        return this.context.getElementByMCID(this.mcid);
    }

    @getIncidentsByChannel
    getIncidentsByChannel() {}

    _onGetContextOnce() {
        // if the Incident belongs to a fragmented context there absolutely
        // no reason to run the getContext method of it
        try {
            if (this.context.fragment === true) {
                return;
            }
            if (!this.gotContext) {
                this.onGetContext();
                this.gotContext = true;
            }
        }
        catch (e) {
            console.log(e);
            console.log(this.mcid);
            // console.log(this.context);
        }
    }

    onGetContext() {
        helper.info('Overwritte the "onGetContext" method with the code you want to get executed', 'info')
    }

    lastWish() {}

    onInitialise() {
        helper.info('Overwritte the "onInialise" method with the code you want to get executed', 'info');
    }

    /**
     * Method called on progress of the timed incident.
     * @param {float} fraction - a number from 0 to 1 representing the fraction of duration covered
     * @param {int} milliseconds - the number of milliseconds passed from start of the incident
     */
    onProgress(fraction, milliseconds) { // eslint-disable-line no-unused-vars

    }

    /**
     * starts the execution of the media from the specified millisecond
     **/
    play(millisecond) {
        return true;
    }

    /**
     * stops the execution of the media
     **/
    stop() {

    }

    @setBlock
    setBlock() {}

    @unblock
    unblock() {}
}

module.exports = MediaPlay;
