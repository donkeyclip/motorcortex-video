function _base64ToArrayBuffer(base64) {
    var binary_string = window.atob(base64);
    var len = binary_string.length;
    var bytes = new Uint8Array(len);
    for (var i = 0; i < len; i++) {
        bytes[i] = binary_string.charCodeAt(i);
    }
    return bytes.buffer;
}

const datamcidRegex = /\[data(-mcid="+\w+")+\]/g;

const Helper = require('../_coreUtils/Helper');
const helper = new Helper();

const AudioNode = require('./helpers/AudioNode');

class PubSub {
    constructor() {
        this.subscribers = [];
    }

    sub(id, method) {
        this.subscribers.push(method);
    }

    pub(argument) {
        for (let i = 0; i < this.subscribers.length; i++) {
            this.subscribers[i](argument);
        }
    }
}

/**
 * Specs:
 * AudioContext Handler keeps all the audio sources.
 * The audio sources are passed in the following format:
 * - src (the source of the sound)
 * - base64 (boolean, defaults to false. If the sound is base64 it's been treated
 *      in a different way)
 * - id (must be unique)
 * - classes (an array of belonging classes)
 *
 * The SoundContextHanlder creates a media element of the following format:
 * media: {
 *  src
 *  id
 *  classes
 *  base64
 *  buffer
 *  nodes: {
 *      stereo
 *      highpass
 *      lowpass
 *      gain
 *      audioNode
 *  }
 * }
 *
 * Finally the SoundContextHandler has its own nodes (the master) which look like this:
 * master: {
 *      stereo
 *      highpass
 *      lowpass
 *      gain
 * }
 **/

class AudioContextHandler {
    constructor(audioSources = {}, masterNode) {
        // variables to be used for checking context rediness
        this.totalSources = audioSources.length;

        // initialisation of the final audio resources colleciton
        this.audioSources = {};

        this.elementsByMCID = {};

        // iterate on audioSource to create the audioSources collection
        for (let i = 0; i < audioSources.length; i++) {
            const audioSource = audioSources[i];
            const audioResource = {
                mcid: audioSource.mcid || helper.getAnId(),
                id: audioSource.id,
                src: audioSource.src,
                classes: audioSource.classes || [],
                base64: audioSource.base64 || false,
                pubSub: new PubSub(),
                soundLoaded: false,
                startValues: audioSource.startValues || {}
            };

            this.audioSources[audioResource.id] = audioResource;

            this.elementsByMCID[audioResource.mcid] = audioResource;

            if (audioSource.base64 === true) {
                helper.getAudioContext().decodeAudioData(_base64ToArrayBuffer(audioSource.src), (buffer) => {
                    this._setBuffer(audioResource, buffer, masterNode);
                });
            }
            else {
                let request = new XMLHttpRequest();
                request.open('GET', audioResource.src, true);
                request.responseType = 'arraybuffer';

                // Decode asynchronously
                this.soundLoaded = false;
                request.onload = () => {
                    helper.getAudioContext().decodeAudioData(request.response, (buffer) => {
                        this._setBuffer(audioResource, buffer, masterNode);
                    }, this.onError);
                }
                request.send();
            }
        }

        this.context = {
            document: document,
            window: window,
            rootElement: document.body,
            unmount: function () {

            },
            masterNode: masterNode,
            audioContext: helper.getAudioContext(),
            getElements: this.getElements.bind(this),
            getMCID: this.getMCID.bind(this),
            setMCID: this.setMCID.bind(this),
            getElementSelectorByMCID: this.getElementSelectorByMCID.bind(this),
            getElementByMCID: this.getElementByMCID.bind(this)
        };
    }

    _setBuffer(audioResource, buffer, masterNode) {
        audioResource.soundLoaded = true;
        audioResource.buffer = buffer;
        audioResource.effectsAudioNode = new AudioNode();
        audioResource.effectsAudioNode.connect(masterNode.input);

        audioResource.pubSub.pub();
    }

    getElementByMCID(mcid) {
        if (Object.prototype.hasOwnProperty.call(this.elementsByMCID, mcid)) {
            return this.elementsByMCID[mcid];
        }
        else {
            return null;
        }
    }

    getElements(selector) {
        if (selector.charAt(0) === "~") {
            selector = selector.substr(1);
            if (selector.charAt(0) === "#") {
                if (Object.prototype.hasOwnProperty.call(this.audioSources, selector.substr(1))) {
                    return [this.audioSources[selector.substr(1)]];
                }
                else {
                    return [];
                }

            }
            else if (selector.charAt(0) === ".") {
                const className = selector.substr(1);
                const toReturn = [];
                for (let source in this.audioSources) {
                    if (source.classes.indexOf(className) >= 0) {
                        toReturn.push(source);
                    }
                }
                return toReturn;
            }
        }
        else if (datamcidRegex.exec(selector)) {
            const mcid = selector.split('"')[1];
            return this.elementsByMCID[mcid];
        }
        else {
            return [];
        }
    }

    getMCID(element) {
        return element.mcid;
    }

    setMCID(element, mcid) {
        element.mcid = mcid;
    }

    getElementSelectorByMCID(mcid) {
        return `[data-mcid="${mcid}"]`;
    }

}

module.exports = AudioContextHandler;
