import bezeasing from 'bezier-easing';
import ClipCopy from '../Clip/ClipCopy';
import incidentFromIngredients from '../IncidentFromDefinition/incidentFromIngredients';
import Leaf from '../Tree/Leaf';
import { _DIRECTIONS } from '../Tree/_CONST';
import easings from '../_coreUtils/easings';
import getIncidentsByChannel from '../_decorators/getIncidentsByChannel';

class ContextAwareClipIncident extends Leaf {
  constructor(constructionIngredients, contextData, mcid, descriptiveIncident) {
    // console.log(constructionIngredients.props);
    super({ id: `${constructionIngredients.incidentId}_${mcid}` });
    // a property to hold all of the contexts
    this.contexts = {};

    this.constructionIngredients = constructionIngredients;
    this.mcid = mcid;
    this._duration = descriptiveIncident.realClip.duration;
    this.DescriptiveIncident = descriptiveIncident;

    this.mc_plugin_npm_name = constructionIngredients.plugin_npm_name;
    this.plugin_channel_class = constructionIngredients.Channel;

    this.addContext(contextData);

    descriptiveIncident.realClip.subscribeToDurationChange((newDuration) => {
      this._duration = newDuration;
      this.putMessageOnPipe('recalcDuration', {}, 'Groups', {
        selfExecute: true,
        direction: _DIRECTIONS._UP,
      });
    });

    this.easing = easings.linear;
    if (Object.prototype.hasOwnProperty.call(this.props, 'easing')) {
      if (Array.isArray(this.props.easing)) {
        this.easing = bezeasing(this.props.easing[0], this.props.easing[1], this.props.easing[2], this.props.easing[3]);
      } else {
        this.easing = easings[this.props.easing];
      }
    }
  }

  get originalContext() {
    return this.contexts[this.originalContextKey];
  }

  get duration() {
    return this._duration;
  }

  onProgress(fraction, milliseconds, contextId, forceReset = false) {
    const eased_MI_fraction = this.easing(fraction) || 0;
    const eased_MI_millisecond = eased_MI_fraction * this.duration;
    // console.log(fraction, eased_MI_fraction, milliseconds, eased_MI_millisecond);
    this.contexts[contextId].onProgress(eased_MI_fraction, eased_MI_millisecond, forceReset);
  }

  addContext(contextData, forceGetContext = false) {
    // if it's the first context to be added then it's the original
    if (Object.keys(this.contexts).length === 0) {
      this.originalContextKey = contextData.clipId;
    }

    // instantiates the Clip so it renders
    const ingredientsToPass = {
      ...this.constructionIngredients,
      context: contextData.context,
      mcid: this.mcid,
      Incident: ClipCopy,
      DescriptiveIncident: this.DescriptiveIncident,
    };
    // and puts it on the corresponding context key
    this.contexts[contextData.clipId] = incidentFromIngredients(ingredientsToPass);
    if (forceGetContext) {
      this.contexts[contextData.clipId]._onGetContextOnce();
    }
  }

  handleAddContext(target, payload) {
    this.addContext(payload, true);
    return true;
  }

  @getIncidentsByChannel
  getIncidentsByChannel() {}

  // massive editing methods that apply the request massively to all of the
  // Incidents of all of the contexts
  gotContext() {
    for (const context in this.contexts) {
      this.contexts[context].gotContext();
    }
  }

  _onGetContextOnce() {
    for (const context in this.contexts) {
      this.contexts[context]._onGetContextOnce();
    }
  }

  lastWish() {
    for (const context in this.contexts) {
      this.contexts[context].lastWish();
    }
  }

  onGetContext() {
    for (const context in this.contexts) {
      this.contexts[context].onGetContext();
    }
  }
}

export default ContextAwareClipIncident;
