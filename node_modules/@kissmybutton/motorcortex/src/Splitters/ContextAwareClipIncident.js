const Leaf = require('../Tree/Leaf');
const incidentFromIngredients = require('../IncidentFromDefinition/incidentFromIngredients');
const ClipCopy = require('../Clip/ClipCopy');
const getIncidentsByChannel = require('../_decorators/getIncidentsByChannel');
const _TREECONST = require('../Tree/_CONST');
const easings = require('../_coreUtils/easings');

class ContextAwareClipIncident extends Leaf {
    constructor(constructionIngredients, contextData, mcid, descriptiveIncident) {
        // console.log(constructionIngredients.props);
        super({ id: `${constructionIngredients.incidentId}_${mcid}` });
        // a property to hold all of the contexts
        this.contexts = {};

        this.constructionIngredients = constructionIngredients;
        this.mcid = mcid;
        this._duration = descriptiveIncident.realClip.duration;
        this.DescriptiveIncident = descriptiveIncident;

        this.mc_plugin_npm_name = constructionIngredients.plugin_npm_name;
        this.plugin_channel_class = constructionIngredients.Channel;

        this.addContext(contextData);

        descriptiveIncident.realClip.subscribeToDurationChange((newDuration) => {
            this._duration = newDuration;
            this.putMessageOnPipe('recalcDuration', {}, 'Groups', { selfExecute: true, direction: _TREECONST._DIRECTIONS._UP });
        });

        this.easing = this.props.easing || 'linear';
    }


    get originalContext() {
        return this.contexts[this.originalContextKey];
    }

    get duration() {
        return this._duration;
    }

    onProgress(fraction, milliseconds, contextId, forceReset = false) {
        const eased_MI_fraction = easings[this.easing](fraction);
        const eased_MI_millisecond = easings[this.easing](milliseconds);
        this.contexts[contextId].onProgress(eased_MI_fraction, eased_MI_millisecond, forceReset);
    }

    addContext(contextData, forceGetContext = false) {
        // if it's the first context to be added then it's the original
        if (Object.keys(this.contexts).length === 0) {
            this.originalContextKey = contextData.clipId;
        }

        // instantiates the Clip so it renders
        const ingredientsToPass = { ...this.constructionIngredients, context: contextData.context, mcid: this.mcid, Incident: ClipCopy, DescriptiveIncident: this.DescriptiveIncident };
        // and puts it on the corresponding context key
        this.contexts[contextData.clipId] = incidentFromIngredients(ingredientsToPass);
        if (forceGetContext === true) {
            this.contexts[contextData.clipId]._onGetContextOnce();
        }
    }

    handleAddContext(target, payload) {
        this.addContext(payload, true);
        return true;
    }

    @getIncidentsByChannel
    getIncidentsByChannel() {}


    // massive editing methods that apply the request massively to all of the
    // Incidents of all of the contexts
    gotContext() {
        for (let context in this.contexts) {
            this.contexts[context].gotContext();
        }
    }

    _onGetContextOnce() {
        for (let context in this.contexts) {
            this.contexts[context]._onGetContextOnce();
        }
    }

    lastWish() {
        for (let context in this.contexts) {
            this.contexts[context].lastWish();
        }
    }

    onGetContext() {
        for (let context in this.contexts) {
            this.contexts[context].onGetContext();
        }
    }


}

module.exports = ContextAwareClipIncident;
