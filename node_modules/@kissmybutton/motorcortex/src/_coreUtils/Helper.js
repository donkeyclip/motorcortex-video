const Validator = require("fastest-validator");

/** @classdesc Helper maintains a number of helpful functions in a single point  */
const conf = require('../_configuration/generalConf');

// audio context initialisation
window.AudioContext = window.AudioContext || window.webkitAudioContext;
const audioContext = new window.AudioContext();

class Helper {
    constructor(configuration) {
        let logLevel = conf.logLevel;

        if (configuration) {
            if (Object.prototype.hasOwnProperty.call(configuration, "logLevel")) {
                logLevel = configuration.logLevel;
            }
        }

        this.lanesMCIDattrsSeperator = '___';

        for (let i = 0; i < conf.logTypes.length; i++) {
            const logType = conf.logTypes[i];
            if (logLevel >= logType.level) {
                if (conf.testMode === true) {
                    this[logType.key] = window.console.log.bind(window.console, `MotorCortex - ${logType.key}: `);
                }
                else {
                    this[logType.key] = window.console.log.bind(window.console, "MotorCortex - %c%s", logType.style);
                }
            }
            else
                this[logType.key] = function () {}
        }

        if (logLevel >= 3) {
            this.log = window.console.log.bind(window.console, `MotorCortex - `);
        }
        else
            this.log = function () {}
    }

    getAudioContext() {
        return audioContext;
    }

    renderTemplate(templateString, templateVars) {
        return new Function("return `" + templateString + "`;").call(templateVars);
    }

    validateProps(props, rules, constructor) {
        const v = new Validator();
        const validationResult = v.validate(props, rules);
        if (validationResult.length > 0) {
            let errorMessage = `Error on plugin's "${constructor.plugin_npm_name}" "${constructor.ClassName}" instantiation. Errors (op props):`;
            for (let i = 0; i < validationResult.length; i++) {
                errorMessage += `\n - ${validationResult[i].message}. ${validationResult[i].actual} provided`;
            }
            console.error(errorMessage);
            return {
                result: false,
                errors: validationResult
            }
        }
        return { result: true }
    }

    /**
     * @returns {string} in the form "1bc45f78-ab23-jl59"
     */
    getAnId(underscore = false) {
        let specialChar = '-';
        if (underscore) {
            specialChar = '_';
        }

        function s4() {
            return Math.floor((1 + Math.random()) * 0x10000)
                .toString(16)
                .substring(1);
        }
        return s4() + s4() + specialChar + s4() + specialChar + s4();
    }

    getLaneKey(mcid, attribute) {
        return mcid + this.lanesMCIDattrsSeperator + attribute;
    }

    getLaneDataFromLaneKey(laneKey) {
        const ar = laneKey.split(this.lanesMCIDattrsSeperator);
        return {
            mcid: ar[0],
            attribute: ar[1]
        }
    }

    getMCIDandAttrOutOfLaneKey(laneKey) {
        const laneArray = laneKey.split(this.lanesMCIDattrsSeperator);
        return {
            mcid: laneArray[0],
            attribute: laneArray[1]
        };
    }

    getElementByMCID(context, mcid) {
        return context.rootElement.querySelectorAll(
            '[' + conf.elements_data_attribute_name + '="' + mcid + '"]'
        )[0];
    }

    /**
	 subdivision might be rounding the number to its:
	 	- units (subdivision = 1)
	 	- tenths (subdivision = 10)
	 	- hundreds (subdivision = 100)
	 	- thousands (subdivision = 1000)
     @param {string} int
     @param {subdivision} int
     @returns {int} the rounded number
	  */
    roundNumberTo(number, subdivision) {
        return Math.round(number / subdivision) * subdivision;
    }

    isInteger(number) {
        if (number === parseInt(number, 10)) {
            return true;
        }
        else {
            return false;
        }
    }

    isString(test) {
        if (typeof test === 'string' || test instanceof String) {
            return true;
        }
        else {
            return false;
        }
    }

    isObject(test) {
        return typeof test === "object";
    }

    isArray(test) {
        return Array.isArray(test);
    }

    isFunction(functionToCheck) {
        return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
    }

    /**
     * systole / diastole of the projections
     * @returns {array} - collection of objects with keys: {id, start, end, startDelta}
     **/
    systoleDiastoleProjections(projections, durationFraction, anchorPoint) {
        let alteredProjections = [];

        for (let i = 0; i < projections.length; i++) {
            let projectedIncident = projections[i];

            const msInResizedPortion = projectedIncident.parentMillisecond - anchorPoint;

            if (durationFraction != 1) {
                alteredProjections.push({
                    id: projectedIncident.incident.id,
                    start: msInResizedPortion * durationFraction + anchorPoint,
                    end: msInResizedPortion * durationFraction + anchorPoint + projectedIncident.incident.duration * durationFraction,
                    startDelta: msInResizedPortion * durationFraction + anchorPoint - projectedIncident.millisecond
                });
            }
        }

        return alteredProjections;
    }

    jsUcfirst(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    }

}

module.exports = Helper;
