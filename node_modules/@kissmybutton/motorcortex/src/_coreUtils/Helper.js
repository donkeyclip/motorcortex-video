import createValidator from '../_coreUtils/customValidations';

import conf, {
  elements_data_attribute_name,
  lanesMCIDattrsSeperator,
  logTypes,
  testMode,
} from '../_configuration/generalConf';

// audio context initialisation
window.AudioContext = window.AudioContext || window.webkitAudioContext;
export const audioContext = new window.AudioContext();

export function isInteger(number) {
  return number === parseInt(number, 10);
}

export function isString(test) {
  return typeof test === 'string' || test instanceof String;
}

export function isObject(test) {
  return typeof test === 'object';
}

export function isFunction(functionToCheck) {
  return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
}

export function jsUcfirst(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

/**
 subdivision might be rounding the number to its:
 - units (subdivision = 1)
 - tenths (subdivision = 10)
 - hundreds (subdivision = 100)
 - thousands (subdivision = 1000)
 @param {number} number
 @param {number} subdivision
 @returns {number} the rounded number
 */
export function roundNumberTo(number, subdivision) {
  return Math.round(number / subdivision) * subdivision;
}

export function getMCIDandAttrOutOfLaneKey(laneKey) {
  const laneArray = laneKey.split(lanesMCIDattrsSeperator);
  return {
    mcid: laneArray[0],
    attribute: laneArray[1],
  };
}

function s4() {
  return Math.floor((1 + Math.random()) * 0x10000)
    .toString(16)
    .substring(1);
}
/**
 * @returns {string} in the form "1bc45f78-ab23-jl59"
 */
export function getAnId(underscore = false) {
  let specialChar = underscore ? '_' : '-';
  return s4() + s4() + specialChar + s4() + specialChar + s4();
}

export function renderTemplate(templateString, templateVars) {
  return new Function(`return \`${templateString}\`;`).call(templateVars); // eslint-disable-line no-new-func
}

export function getLaneKey(mcid, attribute) {
  return `${mcid}${lanesMCIDattrsSeperator}${attribute}`;
}

/** @classdesc Helper maintains a number of helpful functions in a single point  */
export class Helper {
  constructor(configuration) {
    let { logLevel } = conf;

    if (configuration) {
      if (Object.prototype.hasOwnProperty.call(configuration, 'logLevel')) {
        logLevel = configuration.logLevel;
      }
    }

    for (let i = 0; i < logTypes.length; i++) {
      const logType = logTypes[i];
      if (logLevel >= logType.level) {
        this[logType.key] = testMode
          ? window.console.log.bind(window.console, `MotorCortex - ${logType.key}: `)
          : window.console.log.bind(window.console, 'MotorCortex - %c%s', logType.style);
      } else this[logType.key] = function funct() {};
    }

    if (logLevel >= 3) {
      this.log = window.console.log.bind(window.console, 'MotorCortex - ');
    } else this.log = function funct() {};
  }

  validateProps(props, rules, constructor) {
    const v = createValidator();
    const validationResult = v.validate(props, rules);
    if (validationResult.length > 0) {
      let errorMessage = `Error on plugin's "${constructor.plugin_npm_name}" "${constructor.ClassName}" instantiation. Errors (op props):`;
      for (let i = 0; i < validationResult.length; i++) {
        errorMessage += `\n - ${validationResult[i].message}. ${validationResult[i].actual} provided`;
      }
      console.error(errorMessage); // eslint-disable-line no-console
      return {
        result: false,
        errors: validationResult,
      };
    }
    return { result: true };
  }

  getElementByMCID(context, mcid) {
    return context.rootElement.querySelectorAll(`[${elements_data_attribute_name}="${mcid}"]`)[0];
  }

  buildInitialValuesValidationRules(attributeRules) {
    let initialValuesRules = JSON.parse(JSON.stringify(attributeRules));
    function makeOptional(attr) {
      if (typeof attr === 'string' || attr instanceof String) {
        attr = { type: attr };
      }
      attr.optional = true;
      if (attr.type === 'object') {
        for (let key in attr.props) {
          makeOptional(attr.props[key]);
        }
      }
    }
    makeOptional(initialValuesRules);
    return initialValuesRules;
  }

  /**
   * systole / diastole of the projections
   * @returns {array} - collection of objects with keys: {id, start, end, startDelta}
   * */
  systoleDiastoleProjections(projections, durationFraction, anchorPoint) {
    const alteredProjections = [];

    for (let i = 0; i < projections.length; i++) {
      const projectedIncident = projections[i];

      const msInResizedPortion = projectedIncident.parentMillisecond - anchorPoint;

      if (durationFraction !== 1) {
        alteredProjections.push({
          id: projectedIncident.incident.id,
          start: msInResizedPortion * durationFraction + anchorPoint,
          end:
            msInResizedPortion * durationFraction +
            anchorPoint +
            projectedIncident.incident.duration * durationFraction,
          startDelta: msInResizedPortion * durationFraction + anchorPoint - projectedIncident.millisecond,
        });
      }
    }

    return alteredProjections;
  }
}

export default new Helper();
