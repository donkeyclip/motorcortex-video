const Helper = require('../_coreUtils/Helper');
const helper = new Helper();

class Journey {
    constructor(props) {
        if (!Object.prototype.hasOwnProperty.call(props, "incident")) {
            helper.error('Journey constructor expects an Incident on its properties on the key "incident"');
            return false;
        }

        this.memory = props.calpuleMemory;
        this.stations = [];

        this.incident = props.incident;
        this.startMillisecond = this.incident.runTimeInfo.currentMillisecond * 1;
        this.startState = this.incident.runTimeInfo.state + "";
        this.incident.stop();
    }

    station(millisecond) {
        let props = {};
        if (this.stations.length > 0) {
            props.previousStop = this.stations[this.stations.length - 1];
        }
        this.stations.push(millisecond);
        // helper.log(`CAPSULE passes as previousStop: ${props.previousStop}`);
        // helper.log(this.stations);
        this.incident.playableProgress(millisecond / this.incident.duration, millisecond);
    }

    destination(millisecond = null) {
        if (millisecond != null) {
            this.station(millisecond);
        }
        else {
            millisecond = this.stations[this.stations.length - 1];
        }
        this.incident.playableProgress(millisecond / this.incident.duration, millisecond);
        // if the clip was playing start it again
        if (this.startState === 'playing' || (this.startState === "blocked" && this.incident.statusBeforeBlock === "playing")) {
            this.incident.play();
        }
        else {
            if (millisecond >= this.incident.duration) {
                this.incident.complete();
            }
            else {
                this.incident.arm();
            }
        }
        this.memory.push(this.exportJourneyLog);
    }

    exportJourneyLog() {
        return {
            startMillisecond: this.startMillisecond,
            startState: this.startState,
            stations: this.stations
        }
    }
}

class TimeCapsule {
    constructor() {
        this.memory = [];
    }

    startJourney(incident) {
        if (!incident) {
            helper.error('startJourney expects an Incident as an argument');
            return false;
        }

        return new Journey({ incident: incident, calpuleMemory: this.memory });
    }
}

module.exports = TimeCapsule;
