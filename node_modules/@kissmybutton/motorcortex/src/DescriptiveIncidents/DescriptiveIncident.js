const Leaf = require('../Tree/Leaf');
const resize = require('./decorators/resize');
const editAttributes = require('./decorators/editAttributes');
const editProperties = require('./decorators/editProperties');
const selectorGetter = require('./decorators/selector');
const MonoIncident = require('../BaseClasses/MonoIncident');
const AttributeChannel = require('../Channels/Attribute/AttributeChannel');
const rules = require('../_configuration/propsValidationRules');
const Helper = require('../_coreUtils/Helper');
const helper = new Helper();

class DescriptiveIncident extends Leaf {
    constructor(attrs, props) {
        if (props === undefined) {
            props = attrs;
            attrs = {};
        }

        super(props);

        const propsValidation = helper.validateProps({ props }, rules.incidentPropsRule, this.constructor);
        if (propsValidation.result === false) {
            return propsValidation;
        }

        this.inheritedSelector = null;

        this.attrs = attrs;
        if (!Object.prototype.hasOwnProperty.call(props, "duration")) {
            props.duration = 0;
        }
        this.props = props;

        // the passive flag (when true) indicates that the Descriptive Group has been created
        // and passively added to a Clip or a Combo via buildTree method.
        // Defaults to false
        this.passive = false;
    }

    static Incident = MonoIncident;
    static plugin_npm_name = "motor-cortex-js-attribute";
    static Channel = AttributeChannel;
    static ClassName = "Incident";

    @editAttributes
    editAttributes() {}

    @editProperties
    editProperties() {}

    @resize
    resize() {}

    @selectorGetter
    selector() {}

    manageEditAttrProps(newAttrs, type) {
        // get a permanent reference to its parent node
        const parentNode = this.parentNode;
        // get the position of the Incident within its parent
        const position = parentNode.getLeafPosition(this.id);
        // first detach the Incident from its parent
        parentNode.removeIncident(this.id);
        // keep a backup of the current attrs/props
        const oldAttrs = JSON.parse(JSON.stringify(this[type]));
        this[type] = newAttrs;
        const res = parentNode.addIncident(this, position);
        if (res.result === false) {
            parentNode.removeIncident(this.id);
            this[type] = oldAttrs;
            parentNode.addIncident(this, position);
            return res;
        }
        return res;
    }

    detachFromParent() {
        super.detachFromParent();
        this.inheritedSelector = null;
    }

    handleCheckForInvalidSelectors() {
        const selector = this.selector();
        if (selector === null) {
            return {
                id: this.id,
                ClassName: this.constructor.ClassName,
                plugin_npm_name: this.constructor.plugin_npm_name,
                error: 'null selector'
            }
        }
        else if (selector.charAt(0) === "&") {
            return {
                id: this.id,
                ClassName: this.constructor.ClassName,
                plugin_npm_name: this.constructor.plugin_npm_name,
                error: 'relative selector with no inherited selector',
                selector: selector
            }
        }
        else return this.bypass();
    }


    /**
     * The purpose of this method is to export a portable definition that can be
     * later used in order to rebuild the Inicdent at any time
     */
    exportDefinition() {
        return {
            ClassName: this.constructor.ClassName,
            plugin_npm_name: this.constructor.plugin_npm_name,
            attrs: this.attrs,
            props: this.props
        }
    }

}

module.exports = DescriptiveIncident;
