import MonoIncident from '../BaseClasses/MonoIncident';
import AttributeChannel from '../Channels/Attribute/AttributeChannel';
import Leaf from '../Tree/Leaf';
import { incidentPropsRule } from '../_configuration/propsValidationRules';
import helper from '../_coreUtils/Helper';
import editAttributes from './decorators/editAttributes';
import editProperties from './decorators/editProperties';
import getElements from './decorators/getElements';
import resize from './decorators/resize';
import selectorGetter from './decorators/selector';

class DescriptiveIncident extends Leaf {
  constructor(attrs, props) {
    if (props === undefined) {
      props = attrs;
      attrs = {};
    }

    super(props);

    const propsValidation = helper.validateProps({ props }, incidentPropsRule, this.constructor);
    if (!propsValidation.result) {
      return propsValidation;
    }

    this.inheritedSelector = null;

    this.attrs = attrs;
    if (!Object.prototype.hasOwnProperty.call(props, 'duration')) {
      props.duration = 0;
    }
    this.props = props;
    this.attrsValidationRules = {};
    this.propsValidationRules = incidentPropsRule;

    // the passive flag (when true) indicates that the Descriptive Group has been created
    // and passively added to a Clip or a Combo via buildTree method.
    // Defaults to false
    this.passive = false;
  }

  static Incident = MonoIncident;

  static plugin_npm_name = 'motor-cortex-js-attribute';

  static Channel = AttributeChannel;

  static ClassName = 'Incident';

  @editAttributes
  editAttributes() {}

  @editProperties
  editProperties() {}

  @resize
  resize() {}

  @selectorGetter
  selector() {}

  @getElements
  getElements() {}

  manageEditAttrProps(newAttrs, type) {
    // get a permanent reference to its parent node
    const { parentNode } = this;
    // get the position of the Incident within its parent
    const position = parentNode.getLeafPosition(this.id);
    // first detach the Incident from its parent
    parentNode.removeIncident(this.id);
    // keep a backup of the current attrs/props
    const oldAttrs = JSON.parse(JSON.stringify(this[type]));
    this[type] = newAttrs;
    const res = parentNode.addIncident(this, position);
    if (!res.result) {
      parentNode.removeIncident(this.id);
      this[type] = oldAttrs;
      parentNode.addIncident(this, position);
    }
    return res;
  }

  detachFromParent() {
    super.detachFromParent();
    this.inheritedSelector = null;
  }

  handleCheckForInvalidSelectors() {
    const selector = this.selector();
    if (selector === null) {
      return {
        id: this.id,
        ClassName: this.constructor.ClassName,
        plugin_npm_name: this.constructor.plugin_npm_name,
        error: 'null selector',
      };
    }
    if (selector.charAt(0) === '&') {
      return {
        id: this.id,
        ClassName: this.constructor.ClassName,
        plugin_npm_name: this.constructor.plugin_npm_name,
        error: 'relative selector with no inherited selector',
        selector,
      };
    }
    return this.bypass();
  }

  /**
   * The purpose of this method is to export a portable definition that can be
   * later used in order to rebuild the Inicdent at any time
   */
  exportDefinition() {
    return {
      ClassName: this.constructor.ClassName,
      plugin: this.constructor.plugin || this.constructor.plugin_npm_name,
      plugin_npm_name: this.constructor.plugin_npm_name,
      attrs: this.attrs,
      props: this.props,
    };
  }

  /**
   * The purpose of this method is to export an object with "live" / real reference
   * to the Class of the Incident so it can directly by used for Clip creation
   * */
  exportLiveDefinition() {
    return {
      Class: this.constructor,
      attrs: JSON.parse(JSON.stringify(this.attrs)),
      props: JSON.parse(JSON.stringify(this.props)),
    };
  }
}

export default DescriptiveIncident;
