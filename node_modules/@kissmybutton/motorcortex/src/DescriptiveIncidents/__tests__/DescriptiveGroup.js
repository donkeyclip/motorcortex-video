const DG = require('../DescriptiveGroup');
const DI = require('../DescriptiveIncident');

const dg = new DG({
    a: 'a',
    b: 'b'
}, {
    c: 'c',
    d: 'd'
});

const dg2 = new DG({
    c2: 'c',
    d2: 'd'
});

const l1 = new DI({ la: 1.1 }, { lp: 1.1, duration: 1 });
const l2 = new DI({ la: 2.1 }, { lp: 2.1, duration: 1 });

/********************** EDITING OWN ATTRIBUTES & PROPERTIES ********************/
test('editing attributes on an unassigned DG should pass', () => {
    const res = dg.editAttributes({ a: 'a1', b: 'b1' });
    expect(res).toEqual({
        result: true
    });

    expect(dg.attrs).toEqual({
        a: 'a1',
        b: 'b1'
    });
});

test('editing properties on an unassigned DG should pass', () => {
    const res = dg.editProperties({ c: 'c1', d: 'd1' });
    expect(res).toEqual({
        result: true
    });

    expect(dg.props).toEqual({
        c: 'c1',
        d: 'd1'
    });
});

/********************** INITIALISING ONLY WITH PROPERTIES *******************/
test('expect the attributes object to be empty and the properties to be the passed for DG initialised only with props', () => {
    expect(dg2.attrs).toEqual({});
    expect(dg2.props).toEqual({
        c2: 'c',
        d2: 'd'
    });
});

/*********************** CHECK THE ROLE OF THE DG AS THE DECISION AUTHORITY ON A HEADLESS TREE ***************/
test('check that a headless tree identifies as its decision authority its root DG and that it allways allows addIncident on its children groups', () => {
    dg2.addIncident(l1, 100);
    dg.addIncident(dg2, 0);
    const res = dg2.addIncident(l2, 200);
    expect(res).toEqual({ result: true });
})

test('check that a headless tree identifies as its decision authority its root DG and that it allways allows editProperties on its children', () => {
    const res = l2.editProperties({ lp: 1.2 });
    expect(res).toEqual({ result: true });
    expect(l2.props).toEqual({
        lp: 1.2
    });
});

test('check that a headless tree identifies as its decision authority its root DG and that it allways allows editAttributes on its children', () => {
    dg2.addIncident(l1, 100);
    dg2.addIncident(l2, 200);
    dg.addIncident(dg2, 0);
    const res = l2.editAttributes({ la: 1.2 });
    expect(res).toEqual({ result: true });
    expect(l2.attrs).toEqual({
        la: 1.2
    });
});

test('check that a headless tree identifies as its decision authority its root DG and that it always allows moveIncident requests', () => {
    const res = dg2.moveIncident(l1.id, 350);
    expect(res).toEqual({ result: true });
    expect(dg2.children[l1.id]).toEqual({
        id: l1.id,
        leaf: l1,
        position: 350
    });
});

test('check that a headless tree identifies as its decision authority its root DG and that it always allows removeIncident requests', () => {
    const res = dg2.removeIncident(l1.id);
    expect(res).toEqual({ result: true });
});
