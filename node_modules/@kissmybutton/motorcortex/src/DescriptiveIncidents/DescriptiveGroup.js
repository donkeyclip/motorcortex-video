import Group from '../BaseClasses/Group';
import Channel from '../Channels/Channel';
import Node from '../Tree/Node';
import { _DIRECTIONS } from '../Tree/_CONST';
import { groupPropsRule } from '../_configuration/propsValidationRules';
import helper from '../_coreUtils/Helper';
import editAttributes from './decorators/editAttributes';
import editProperties from './decorators/editProperties';
import getElements from './decorators/getElements';
import resize from './decorators/resize';
import selectorGetter from './decorators/selector';
import { _TARGETTYPES } from './_CONST';

class DescriptiveGroup extends Node {
  static Incident = Group;

  static plugin_npm_name = 'motor-cortex-js';

  static Channel = Channel;

  static ClassName = 'Group';

  static isGroup = true;

  constructor(attrs = {}, props = null) {
    if (props === null) {
      super(attrs);
      this.attrs = {};
      this.props = attrs;
    } else {
      super(props);
      this.attrs = attrs;
      this.props = props;
    }

    const propsValidation = helper.validateProps(this.props, groupPropsRule, this.constructor);
    if (!propsValidation.result) {
      return propsValidation;
    }
    this.attrsValidationRules = {};
    this.propsValidationRules = groupPropsRule;

    this._inheritedSelector = null;

    // passiveAddition is a flag property indicating that any Incident to be
    // added to the Clip will be passive. It initialises with value = false
    // on DescriptiveGroup where it's originaly defined.
    // Here we change its value just before the buildTree method execution
    // so all Incidents added on it get the "passive" flag and don't get
    // exported on the exportDefinition method. Once the buildTree method
    // finishes we set it back to its original value (false)
    this.passiveAddition = true;
    this._buildTree();
    this.passiveAddition = false;
  }

  @editAttributes
  editAttributes() {}

  @editProperties
  editProperties() {}

  @resize
  resize() {}

  @selectorGetter
  selector() {}

  @getElements
  getElements() {}

  _buildTree() {
    this.buildTree();
  }

  _rebuildTree() {
    // remove all direct passive incidents as they might be dependent on the edited attrs/props
    for (const id in this.children) {
      const theChild = this.children[id];
      if (theChild.leaf.passive === true) {
        this.removeIncident(theChild.id);
      }
    }
    // run buildTree again
    this.passiveAddition = true;
    this.buildTree();
    this.passiveAddition = false;
  }

  buildTree() {}

  manageEditAttrProps(newAttrs, type) {
    // get a permanent reference to its parent node
    const { parentNode } = this;
    // get the position of the Incident within its parent
    const position = parentNode.getLeafPosition(this.id);
    // keep a backup of the current attrs / props
    const oldAttrs = JSON.parse(JSON.stringify(this[type]));
    this[type] = newAttrs;
    // first detach the Incident from its parent
    parentNode.removeIncident(this.id);
    // remove all direct passive incidents as they might be dependent on the edited attrs/props
    this._rebuildTree();
    // try to add the altered Group
    const res = parentNode.addIncident(this, position);

    if (!res.result) {
      this[type] = oldAttrs;
      this._rebuildTree();
      parentNode.addIncident(this, position);
      return res;
    }
    return res;
  }

  detachFromParent() {
    super.detachFromParent();
    this.inheritedSelector = null;
  }

  get inheritedSelector() {
    return this._inheritedSelector;
  }

  set inheritedSelector(value) {
    this._inheritedSelector = value;
    for (const id in this.children) {
      const theChild = this.children[id].leaf;
      theChild.inheritedSelector = this.selector();
    }
  }

  get selectorToPassToChildren() {
    return this.selector();
  }

  /**
   * The purpose of this method is to export a portable definition that can be
   * later used in order to rebuild the Inicdent at any time
   */
  exportDefinition() {
    const toReturn = {
      ClassName: this.constructor.ClassName,
      plugin_npm_name: this.constructor.plugin_npm_name,
      attrs: this.attrs,
      props: this.props,
      incidents: {},
      duration: this.duration,
    };

    for (const id in this.children) {
      const theChild = this.children[id];
      if (theChild.leaf.passive === true) {
        continue;
      }
      toReturn.incidents[id] = {
        id: theChild.id,
        position: theChild.position,
        leaf: theChild.leaf.exportDefinition(),
      };
    }

    return toReturn;
  }

  /**
   * The purpose of this method is to export an object with "live" / real reference
   * to the Class of the Incident so it can directly by used for Clip creation
   * */
  exportLiveDefinition() {
    const toReturn = {
      Class: this.constructor,
      attrs: JSON.parse(JSON.stringify(this.attrs)),
      props: JSON.parse(JSON.stringify(this.props)),
      incidents: {},
    };

    for (const id in this.children) {
      const theChild = this.children[id];
      if (theChild.leaf.passive === true) {
        continue;
      }
      toReturn.incidents[id] = {
        id: theChild.id,
        position: theChild.position,
        leaf: theChild.leaf.exportLiveDefinition(),
      };
    }

    return toReturn;
  }

  addIncident(descriptiveIncident, position, options = { check: true }) {
    descriptiveIncident.inheritedSelector = this.selectorToPassToChildren;
    if (options.check === true) {
      const initialCheck = super.checkAddition(descriptiveIncident, position);
      if (!initialCheck.result) {
        descriptiveIncident.inheritedSelector = null;
        return initialCheck;
      }

      /* Check for null or relative selector Incidents with no inherited selector */
      const checkIfBelongsToClip = this.putMessageOnPipe('checkForClip', {}, _TARGETTYPES._DECISIONAUTHORITY, {
        selfExecute: true,
        direction: _DIRECTIONS._UP,
      });
      if (checkIfBelongsToClip.response === true) {
        // if the Group belongs on a Clip
        const selectorsCheck = descriptiveIncident.putMessageOnPipe('checkForInvalidSelectors', {}, null, {
          selfExecute: true,
          direction: _DIRECTIONS._DOWN,
        });
        if (selectorsCheck.length > 0) {
          const errors = [];
          for (let i = 0; i < selectorsCheck.length; i++) {
            errors.push(selectorsCheck[i].response);
          }
          return {
            result: false,
            errors,
          };
        }
      }

      // sends the check request to its root, either a headless root or a Descriptive Clip
      const mcCheck = this.putMessageOnPipe(
        'checkAddition',
        {
          incident: descriptiveIncident,
          millisecond: position,
          parentGroupId: this.id,
        },
        _TARGETTYPES._DECISIONAUTHORITY,
        { selfExecute: true, direction: _DIRECTIONS._UP }
      );
      if (!mcCheck.response.result) {
        descriptiveIncident.inheritedSelector = null;
        return mcCheck.response;
      }
    }

    // if the passiveAddition flag is true we set the passive flag of the Incident
    // to true before adding it to our Group
    if (this.passiveAddition === true) {
      descriptiveIncident.passive = true;
    }

    const res = this.addChild(descriptiveIncident, position);
    if (!res.result) {
      descriptiveIncident.inheritedSelector = null;
    }
    return res;
  }

  /**
   * @param input - can either be object or id
   * */
  moveIncident(input, position) {
    let id = input;
    if (typeof input === 'object') {
      id = input.id;
    }

    const initialCheck = super.checkEditPosition(id, position);

    if (!initialCheck.result) {
      return initialCheck;
    }

    const originalPosition = this.getLeafPosition(id);
    const positionDelta = position - originalPosition;
    if (positionDelta === 0) {
      return { result: true };
    }

    const mcCheck = this.putMessageOnPipe(
      'checkMove',
      {
        id,
        millisecond: position,
        positionDelta,
        parentGroupId: this.id,
      },
      _TARGETTYPES._DECISIONAUTHORITY,
      { selfExecute: true, direction: _DIRECTIONS._UP }
    );
    if (!mcCheck.response.result) {
      return mcCheck.response;
    }

    return this.editPosition(id, position);
  }

  removeIncident(input) {
    let id = input;
    if (typeof input === 'object') {
      id = input.id;
    }

    const initialCheck = super.checkRemoveChild(id);

    if (!initialCheck.result) {
      return initialCheck;
    }

    const mcCheck = this.putMessageOnPipe(
      'checkDeletion',
      { id, parentGroupId: this.id },
      _TARGETTYPES._DECISIONAUTHORITY,
      { selfExecute: true, direction: _DIRECTIONS._UP }
    );
    if (!mcCheck.response.result) {
      return mcCheck.response;
    }

    const res = this.removeChild(id);
    return res;
  }

  /** ************************* HANDLING METHODS ****************************** */
  // eslint-disable-next-line no-unused-vars
  handleCheckForClip(target, payload) {
    if (this.hasParent) {
      return this.bypass();
    }
    return false;
  }

  // eslint-disable-next-line no-unused-vars
  handleCheckAddition(target, payload) {
    /*
        The DescriptiveGroup handles the checkAddition command which has the UP
        direction. If the DG has a parent it forwards the command to it. If not
        it just returns true, as it is a deadless tree
        */
    if (this.hasParent) {
      return this.bypass();
    }
    return {
      result: true,
    };
  }

  // eslint-disable-next-line no-unused-vars
  handleCheckMove(target, payload) {
    if (this.hasParent) {
      return this.bypass();
    }

    return {
      result: true,
    };
  }

  // eslint-disable-next-line no-unused-vars
  handleCheckDeletion(target, payload) {
    if (this.hasParent) {
      return this.bypass();
    }

    return {
      result: true,
    };
  }

  // eslint-disable-next-line no-unused-vars
  handleCheckResize(target, payload) {
    if (this.hasParent) {
      return this.bypass();
    }

    return {
      result: true,
    };
  }
}

export default DescriptiveGroup;
