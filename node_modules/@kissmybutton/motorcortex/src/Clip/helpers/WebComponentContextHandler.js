/*
iframe[seamless]{
    background-color: transparent;
    border: 0px none transparent;
    padding: 0px;
    overflow: hidden;
}

might need more work for IE. See here: https://stackoverflow.com/a/29209248
*/

const Helper = require('../../_coreUtils/Helper');
const helper = new Helper();
const ContextHandler = require('./ContextHandler');

class WebComponentContextHandler extends ContextHandler {
    /**
     * @param {object} props - an object that should contain all of the following keys:
     * - html (the html template to render)
     * - css (the css template of the isolated tree)
     * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)
     * - host (an Element object that will host the isolated tree)
     * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)
     */
    constructor(props = {}) {
        super();
        if (!helper.isObject(props)) {
            helper.error(`ContextHandler expects an object on its constructor. ${typeof props} passed`);
            return false;
        }

        if (!Object.prototype.hasOwnProperty.call(props, "html")) {
            helper.error(`ContextHandler expects the html key on its constructor properties which is missing`);
            return false;
        }

        if (!Object.prototype.hasOwnProperty.call(props, "css")) {
            helper.error(`ContextHandler expects the css key on its constructor properties which is missing`);
            return false;
        }

        if (!Object.prototype.hasOwnProperty.call(props, "host")) {
            helper.error(`ContextHandler expects the host key on its constructor properties which is missing`);
            return false;
        }

        this.isDOM = true;

        const shadow = props.host.attachShadow({ mode: 'closed' });
        const wrapper = document.createElement('div');
        if (Object.prototype.hasOwnProperty.call(props, "containerParams")) {
            if (Object.prototype.hasOwnProperty.call(props.containerParams, "width")) {
                wrapper.style.width = props.containerParams.width;
            }
            if (Object.prototype.hasOwnProperty.call(props.containerParams, "height")) {
                wrapper.style.height = props.containerParams.height;
            }
        }
        wrapper.innerHTML = helper.renderTemplate(props.html + '<slot></slot>', { params: props.initParams });
        shadow.appendChild(wrapper);

        const styleTag = document.createElement('style');
        styleTag.type = 'text/css';
        if (styleTag.styleSheet) {
            styleTag.styleSheet.cssText = helper.renderTemplate(props.css, { params: props.initParams });
        }
        else {
            styleTag.appendChild(document.createTextNode(props.css));
        }
        shadow.appendChild(styleTag);

        this.fontTags = [];
        if (Object.prototype.hasOwnProperty.call(props, "fonts")) {
            for (let i = 0; i < props.fonts.length; i++) {
                const theFont = props.fonts[i];
                if (theFont.type === "google-font") {
                    const fontTag = document.createElement('link');
                    fontTag.setAttribute('rel', 'stylesheet');
                    fontTag.setAttribute('href', theFont.src);
                    document.getElementsByTagName('head')[0].appendChild(fontTag);
                    this.fontTags.push(fontTag);
                }
            }
        }

        wrapper.style.overflow = "hidden";

        this.rootElement = wrapper;

        this.context = {
            document: document,
            window: window,
            clipContainer: this.rootElement,
            rootElement: wrapper,
            unmount: function () {
                try {
                    props.host.removeChild(shadow);
                    for (let i = 0; i < this.fontTags.length; i++) {
                        document.getElementsByTagName('head')[0].removeChild(this.fontTags[i]);
                    }
                }
                catch (er) {
                    helper.warning('The element of the Clip to be removed seems not to exist any more');
                }
            },
            getElements: this.getElements.bind(this),
            getMCID: this.getMCID.bind(this),
            setMCID: this.setMCID.bind(this),
            getElementSelectorByMCID: this.getElementSelectorByMCID.bind(this),
            getElementByMCID: this.getElementByMCID.bind(this),
            setCustomEntity: this.setCustomEntity.bind(this)
        };

        this.elementsByMCID = {};
    }
}

module.exports = WebComponentContextHandler;
