const Helper = require('../_coreUtils/Helper');
const helper = new Helper();
const DescriptiveGroup = require('../DescriptiveIncidents/DescriptiveGroup');
const _TREECONST = require('../Tree/_CONST');

class Playable extends DescriptiveGroup {
    constructor(attrs, props) {
        super(attrs, props);
        this.runTimeInfo = {
            currentMillisecond: 0,
            state: 'idle' // supported states: idle, playing, paused, blocked, armed
        };

        /**
          @member {object} - listeners are functions to be executed on time change of the Clip.
          It has the following format:
         listeners: {
            listener_id: {
                     funct : the function to be executed
                     threshold : the threshold of delta
                     roundTo : round millisecond
                 },
                 listener_id: {
                     funct : the function to be executed
                     threshold : the threshold of delta
                     roundTo : round millisecond
                 },
                 ...
           }
           */
        this.listeners = {};

        // previousTimeStamp is a property holding the last timestamp that the
        // requestAnimationFrame ran
        this.previousTimeStamp = -1;

        this.speed = 1;
    }

    /*********************** execution methods  *********************
     ****************************************************************/
    _setState(newState) {
        if (newState != this.runTimeInfo.state) {
            this.runTimeInfo.state = newState;
            // the only timer and the only responsible for Clip execution is the Clip
            // All Incidents contained on a Clip are been executed by the Clip itself via its channels.
            // Thus, the only Incidents that need to know about the state of the root Clip
            // at any time are only the Clips
            this.putMessageOnPipe('setState', newState, 'Clips', { selfExecute: false, direction: _TREECONST._DIRECTIONS._DOWN });
            for (const key in this.listeners) {
                const listner = this.listeners[key];
                listner.funct(this.runTimeInfo.currentMillisecond, newState);
            }
        }
    }

    handleSetState(target, payload) {
        this._setState(payload);
    }

    // execution methods
    play(debug = false) {
        if (this.runTimeInfo.state === 'idle' || this.runTimeInfo.state === 'paused' || this.runTimeInfo.state === 'armed' ||
            this.runTimeInfo.state === 'transitional' || this.runTimeInfo.state === "blocked") {
            if (this.runTimeInfo.state === 'paused') {
                const delta = new Date().getTime() - this.pauseMoment;
                this.previousTimeStamp += delta;
            }

            this._setState('playing');
            this.onPlay();
            if (debug === false) {
                window.requestAnimationFrame((timestamp) => {
                    this.step(timestamp);
                });
            }
        }
    }

    pause() {
        if (this.runTimeInfo.state === 'playing') {
            this._setState('paused');
            this.pauseMoment = new Date().getTime();
            this.onWait();
        }
    }

    /* armed state means the Clip is on paused state after transition */
    arm() {
        if (this.runTimeInfo.state === 'transitional') {
            this._setState('armed');
        }
    }

    complete() {
        this._setState('idle');
        this.previousTimeStamp = -1;
    }

    /* in order to start a journey via the TimeCapsule the Playable needs first to stop */
    stop() {
        this._setState('transitional');
        this.previousTimeStamp = -1;
    }

    block() {
        this._setState('blocked');
        this.previousTimeStamp = -1;
    }


    onPlay() {

    }

    onWait() {

    }

    playableProgress(fraction, millisecond) {
        if (this.isTheRootClip) {
            for (const key in this.listeners) {
                const listner = this.listeners[key];
                // if the listener is only for state change continue
                if (listner.onlyOnStateChange === true) {
                    continue;
                }
                // console.log(`Math.abs(${milliseconds} + ${listner.cavaDelta} - ${this.runTimeInfo.currentMillisecond}) > ${listner.threshold}`);
                if (Math.abs(millisecond + listner.cavaDelta - this.runTimeInfo.currentMillisecond) > listner.threshold) {
                    listner.funct(helper.roundNumberTo(millisecond, listner.roundTo), this.runTimeInfo.state);
                    listner.cavaDelta = 0;
                }
                else {
                    listner.cavaDelta += Math.abs(millisecond - this.runTimeInfo.currentMillisecond);
                }
            }
            this.onProgress(fraction, millisecond);

            this.runTimeInfo.currentMillisecond = millisecond;
            return true;
        }
        return false;
    }

    set executionSpeed(speed) {
        if (!this.isTheRootClip) {
            return false;
        }
        this.speed = parseFloat(speed);
    }

    // *******************************************************
    // STEP FUNCTION
    step(timestamp, debug = false) {
        if (this.runTimeInfo.state !== 'playing') {
            return;
        }

        const that = this;
        if (this.previousTimeStamp === -1) {
            this.previousTimeStamp = timestamp;
        }

        // progressStep is the progress made from previousTimeStamp both in milliseconds and in fraction [0 to 1]
        const progress = {
            milliseconds: Math.round(this.runTimeInfo.currentMillisecond + (timestamp - this.previousTimeStamp) * this.speed),
            fraction: (this.runTimeInfo.currentMillisecond + (timestamp - this.previousTimeStamp) * this.speed) / this.duration
        };

        if (progress.fraction >= 1) {
            this.playableProgress(1, this.duration);
            this.complete();
            return;
        }
        else if (progress.fraction < 0) {
            this.playableProgress(0, 0);
            this.complete();
            // this.broadcastEvent('state-change', { oldState: "playing", newState: "idle" });
            return;
        }

        this.playableProgress(progress.fraction, progress.milliseconds);

        this.previousTimeStamp = timestamp;

        if (debug === false) {
            window.requestAnimationFrame(that.step.bind(that));
        }
    }


    // ************ PUB SUB ********************
    // *****************************************
    /**
      By subscribing a module can get notified about changes on the Clip's time
      subscribe method subscribes a function to the time change dispatcher. As Clip uses requestAnimationFrame for its timing
      each cyrcle / step gets the current time and subtracts the previous time so it know how many milliseconds has elapsed
      since last step. Subscribers can set to get informed about time changes only if the delta is greater than a given
      number (e.g. greater than 300ms). That property is passed as the second argument "threshold".
      Finally if any of the subscribers want the Scene to provide back a rounded number of the milliseconds. Options:
        - 1 (round it on its actual units
       - 10 (round it on tenths)
       - 100 (round it on hundreds)
       - 1000 (round it on thousands)
      the first argument provides an id to the listener for future reference (deletion etc)
      the second argument is a function that takes two arguments: millisecond, state (current millisecond of the Scene
      and the state of it  */
    subscribe(id, funct, threshold, roundTo, onlyOnStateChange = false) {
        if (!threshold) {
            threshold = 0;
        }
        if (!roundTo) {
            roundTo = 1; // round second to its units, meaning leave it as it is
        }
        this.listeners[id] = {
            funct: funct,
            threshold: threshold,
            roundTo: roundTo,
            cavaDelta: 0,
            onlyOnStateChange: onlyOnStateChange
        };
    }

    unsubscribe(id) {
        if (Object.prototype.hasOwnProperty.call(this.listeners, id)) {
            delete this.listeners[id];
        }
    }

    subscribeToDurationChange(funct) {
        if (this.isTheRootClip) {
            this.realClip.subscribeToDurationChange(funct);
            return true;
        }
        return false;
    }
}

module.exports = Playable;
