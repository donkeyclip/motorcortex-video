const conf = require('../_configuration/generalConf');

// context handlers
const IframeContextHandler = require('./helpers/IframeContextHandler');
const WebComponentContextHandler = require('./helpers/WebComponentContextHandler');

const ExtendableClip = require('./ExtendableClip');

class Clip extends ExtendableClip {
    /**
     * @param {object} props - an object that should contain all of the following keys:
     * - html (the html template to render)
     * - css (the css template of the isolated tree)
     * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)
     * - host (an Element object that will host the isolated tree)
     * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)
     */
    constructor(props = {}, oldProps = null) {
        let attrsToPass, propsToUse;
        /*
        backwards compatibility. If the user doesn't pass a second argument on the constructor then this is
        the new way of initialising a Group (only props).
        */
        if (oldProps === null) {
            attrsToPass = {};
            propsToUse = props;
        }
        else { // else, in case the user has passed two arguments then both should be used
            attrsToPass = props;
            propsToUse = oldProps;
        }

        super(attrsToPass, propsToUse);

        propsToUse = {
            ...propsToUse,
            html: this.html != '' ? this.html : propsToUse.html,
            css: this.css != '' ? this.css : propsToUse.css,
            fonts: this.fonts.length > 0 ? this.fonts : propsToUse.fonts
        };

        // that means the Clip is hosted or, in other words a host has been
        // provided on the props (and not a selector)
        // this.isHostedClip = true;

        let clipType = conf.selfContainedContextHandler;
        this.clipType = clipType;

        let ContextHanlder = null;

        if (document.head.createShadowRoot || document.head.attachShadow) {
            ContextHanlder = WebComponentContextHandler;
        }
        else {
            ContextHanlder = IframeContextHandler;
        }

        // console.log(`this.id: ${this.id}, Class: ${this.constructor.name}, this.html: ${this.html}`)
        const contextHanlder = new ContextHanlder(propsToUse);

        this.ownContext = { ...contextHanlder.context, isHostedClip: this.isHostedClip };
        this.iframe = contextHanlder.iframeElement;

        this.forceExportIncidents = true;

        this.onAfterRender();
    }

    onAfterRender() {
        // implement here
    }

    get html() {
        return '';
    }

    get css() {
        return '';
    }

    get fonts() {
        return [];
    }

    get rootElement() {
        return this.ownContext.clipContainer;
    }

    exportConstructionArguments() {
        // TODO also export CSS and fonts taking in account the potential existance
        // of them on the get methods
        return {
            attrs: this.attrs,
            props: { ...this.props, host: undefined, html: this.ownContext.rootElement.innerHTML }
        }
    }

    setCustomEntity(id, entity, classes = []) {
        return this.context.setCustomEntity(id, entity, classes);
    }

}

module.exports = Clip;
