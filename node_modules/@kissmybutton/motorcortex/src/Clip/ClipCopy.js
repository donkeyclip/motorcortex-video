const MonoIncident = require('../BaseClasses/MonoIncident');
const Helper = require('../_coreUtils/Helper');
const helper = new Helper();

class ClipCopy extends MonoIncident {
    constructor(attrs, props, dna) {
        super(attrs, props, dna);

        this.runTimeInfo = {
            currentMillisecond: 0
        };
    }

    get duration() {
        return this.DescriptiveIncident.realClip.duration;
    }

    set duration(milliseconds) {
        this.DescriptiveIncident.realClip._resize(milliseconds / this.realClip.duration);
    }

    lastWish() {
        this.ownClip.ownContext.unmount();
    }

    onGetContext() {
        // In order to render itself on the given element first it needs the props (including html and css)
        // from the real Clip it copies
        const constructionArgs = this.DescriptiveIncident.realClip.exportConstructionArguments();
        // it properly sets its own host on the props to use to initialise its own clip
        const host = helper.getElementByMCID(this.context, this.mcid);
        const hostedProps = { ...constructionArgs.props, selector: undefined, host: host };
        // we create a clip because Clips on creation render and thus have their own context
        // this.dna.descriptiveIncident.constructor.Incident keeps a reference to the non-audio real Clip
        // Class. No audio is involved on this process
        this.ownClip = new this.DescriptiveIncident.constructor.Incident(constructionArgs.attrs, hostedProps);
        this.ownClip.DescriptiveIncident = this.DescriptiveIncident;

        this.ownClip.contextLoaded = this.contextLoaded.bind(this);

        // console.log(this.ownClip);
        // flushes the realClip with its ownClip's context
        this.DescriptiveIncident.realClip.addContext({
            clipId: this.id,
            context: this.ownClip.ownContext
        }, true);
        // even though we have created an own clip, we have made no checks at all neither
        // we added the incidents of the real clip to it. That is becuase playing and moving
        // this clip copy means directly moving the real clip on the context of the own clip.
        // So the only thing we need here is the context and nothing more.

        this.contextReady = true;
    }

    contextLoaded() {
        this.contextReady = true;
        this.unblock();
    }

    onProgress(fraction, milliseconds, forceReset = false) {
        if (this.ownClip.ownContext.loading === true) {
            this.setBlock();
            return;
        }
        for (let key in this.DescriptiveIncident.realClip.instantiatedChannels) {
            const channel = this.DescriptiveIncident.realClip.instantiatedChannels[key];
            channel.moveTo(this.runTimeInfo.currentMillisecond, milliseconds, this.id, forceReset);
        }
        this.runTimeInfo.currentMillisecond = milliseconds;
        this.ownClip.onAfterProgress(fraction, milliseconds);
    }

}

module.exports = ClipCopy;
