import { getAnId, jsUcfirst } from '../_coreUtils/Helper';
import systoleDiastole from './decorators/systoleDiastole';
import { _BYPASS, _DIRECTIONS } from './_CONST';

class Leaf {
  constructor(props = {}) {
    // parentNode is a reference to the parent Node the Leaf is attached to (if any)
    this.parentNode = null;
    this.isNode = false;

    if (Object.prototype.hasOwnProperty.call(props, 'id')) {
      this.id = props.id;
    } else {
      this.id = getAnId();
    }

    this.props = props;
  }

  get delay() {
    if (Object.prototype.hasOwnProperty.call(this.props, 'delay')) {
      return this.props.delay;
    }
    return 0;
  }

  set delay(val) {
    if (val !== 0) {
      this.props.delay = val;
    }
  }

  get hiatus() {
    if (Object.prototype.hasOwnProperty.call(this.props, 'hiatus')) {
      return this.props.hiatus;
    }
    return 0;
  }

  set hiatus(val) {
    if (val !== 0) {
      this.props.hiatus = val;
    }
  }

  get repeats() {
    if (Object.prototype.hasOwnProperty.call(this.props, 'repeats')) {
      return this.props.repeats;
    }
    return 1;
  }

  set repeats(val) {
    this.props.repeats = val;
  }

  /**
   * the full duration of the Leaf taking in consideration all: delay, duration, hiatus and
   * repeats factor
   * */
  get duration() {
    return this.repeats * (this.delay + this.props.duration + this.hiatus);
  }

  /**
   * the setter sets the overall duration of the Leaf by altering all
   * delay, duration and hiatus properties of it
   * */
  set duration(milliseconds) {
    const fraction = milliseconds / this.duration;
    this.props.duration *= fraction;
    this.hiatus *= fraction;
    this.delay *= fraction;
  }

  /**
   * setNewDuration method sets the new FULL duration as it derives from the
   * delay, duration, hiatus and repeats factors
   * */
  setNewDuration(newDuration) {
    this.duration = newDuration;
    this.putMessageOnPipe('recalcDuration', {}, 'Groups', {
      selfExecute: false,
      direction: _DIRECTIONS._UP,
    });
  }

  @systoleDiastole
  systoleDiastole() {}

  get hasParent() {
    return this.parentNode !== null;
  }

  attachToNode(node) {
    this.parentNode = node;
  }

  detachFromParent() {
    this.parentNode = null;
  }

  /**
  @param {string} name - the name of the message
  @param {object} payload - the payload of the message
  @param {object} target - specifies the target of the message in a key-value pairs object
  @param {object} options - in the form:
  {
      direction (either _UP or _DOWN)
      selfExecute (either true which means the Leaf should try to handle the message itself or
          false which means the Leaf should directly forward the message to its parent)
  }
  @returns The expected result of this method is on the form:
  {
      response: an object the structure of which depends on the name of the message
          and maybe even on the payload
      responder: a direct reference to the lead that actually responded
      (only valid for direaction _DOWN) positionDelta: the position delta of the responder compared to the requester
  }
  * */
  putMessageOnPipe(name, payload, target, options = {}) {
    // default direction: _DOWN
    if (!Object.prototype.hasOwnProperty.call(options, 'direction')) {
      options.direction = _DIRECTIONS._DOWN;
    }

    // default positionDelta = 0
    if (options.direction === _DIRECTIONS._DOWN && !Object.prototype.hasOwnProperty.call(options, 'positionDelta')) {
      options.positionDelta = 0;
    }

    if (options.selfExecute) {
      // if the Leaf has a "handle<name>" method with the first letter of
      // name in Capital it runs it
      const handlingMethodName = `handle${jsUcfirst(name)}`;
      const capable = typeof this[handlingMethodName] === 'function';

      if (capable) {
        const response = this[handlingMethodName](target, payload);
        if (response !== _BYPASS) {
          const result = {
            response,
            responder: this,
          };
          if (options.direction === _DIRECTIONS._UP) {
            return result;
          }

          return [{ ...result, positionDelta: options.positionDelta }];
        }
      }
    }

    if (options.direction === _DIRECTIONS._UP) {
      if (this.hasParent) {
        return this.parentNode.putMessageOnPipe(name, payload, target, {
          selfExecute: true,
          direction: _DIRECTIONS._UP,
        });
      }
      // if the message reaches the top of the tree without finding any liable target
      return {
        response: false,
        responder: null,
      };
    }
    // _CONST._DIRECTIONS._DOWN
    return [];
  }

  bypass() {
    return _BYPASS;
  }

  // Postion on Pyramidion
  // "Pyramidion" is the uppermost piece or capstone of an Egyptian pyramid.
  // To us "Pyramidion" is the top Node of the Tree to which this Leaf belongs to
  // and the following infrastructure implements it
  get positionOnPyramidion() {
    return this.getPositionOnPyramidion();
  }

  getPositionOnPyramidion(delta = 0) {
    if (!this.hasParent) {
      return delta;
    } else {
      const result = this.putMessageOnPipe('getPositionOnPyramidion', { delta, id: this.id }, 'Parent', {
        selfExecute: false,
        direction: _DIRECTIONS._UP,
      });
      return result.response;
    }
  }
}

export default Leaf;
