const _CONST = require('./_CONST');
const Helper = require('../_coreUtils/Helper');
const helper = new Helper();
const systoleDiastole = require('./decorators/systoleDiastole');

class Leaf {
    constructor(props = {}) {
        // parentNode is a reference to the parent Node the Leaf is attached to (if any)
        this.parentNode = null;
        this.isNode = false;

        if (Object.prototype.hasOwnProperty.call(props, "id")) {
            this.id = props.id;
        }
        else {
            this.id = helper.getAnId();
        }

        this.props = props;
    }

    get delay() {
        if (Object.prototype.hasOwnProperty.call(this.props, "delay")) {
            return this.props.delay;
        }
        return 0;
    }

    set delay(val) {
        if (val != 0) {
            this.props.delay = val;
        }
    }

    get hiatus() {
        if (Object.prototype.hasOwnProperty.call(this.props, "hiatus")) {
            return this.props.hiatus;
        }
        return 0;
    }

    set hiatus(val) {
        if (val != 0) {
            this.props.hiatus = val;
        }
    }

    get repeats() {
        if (Object.prototype.hasOwnProperty.call(this.props, "repeats")) {
            return this.props.repeats;
        }
        return 1;
    }

    set repeats(val) {
        this.props.repeats = val;
    }

    /**
     * the full duration of the Leaf taking in consideration all: delay, duration, hiatus and
     * repeats factor
     **/
    get duration() {
        return this.repeats * (this.delay + this.props.duration + this.hiatus);
    }

    /**
     * the setter sets the overall duration of the Leaf by altering all
     * delay, duration and hiatus properties of it
     **/
    set duration(milliseconds) {
        const fraction = milliseconds / this.duration;
        this.props.duration *= fraction;
        this.hiatus *= fraction;
        this.delay *= fraction;
    }

    /**
     * setNewDuration method sets the new FULL duration as it derives from the
     * delay, duration, hiatus and repeats factors
     **/
    setNewDuration(newDuration) {
        this.duration = newDuration;
        this.putMessageOnPipe('recalcDuration', {}, 'Groups', { selfExecute: false, direction: _CONST._DIRECTIONS._UP });
    }

    @systoleDiastole
    systoleDiastole() {}

    get hasParent() {
        if (this.parentNode === null) {
            return false;
        }
        return true;
    }

    attachToNode(node) {
        this.parentNode = node;
    }

    detachFromParent() {
        this.parentNode = null;
    }

    /**
    @param {string} name - the name of the message
    @param {object} payload - the payload of the message
    @param {object} target - specifies the target of the message in a key-value pairs object
    @param {object} options - in the form:
    {
        direction (either _UP or _DOWN)
        selfExecute (either true which means the Leaf should try to handle the message itself or
            false which means the Leaf should directly forward the message to its parent)
    }
    @returns The expected result of this method is on the form:
    {
        response: an object the structure of which depends on the name of the message
            and maybe even on the payload
        responder: a direct reference to the lead that actually responded
        (only valid for direaction _DOWN) positionDelta: the position delta of the responder compared to the requester
    }
    **/
    putMessageOnPipe(name, payload, target, options = {}) {
        // default direction: _DOWN
        if (!Object.prototype.hasOwnProperty.call(options, "direction")) {
            options.direction = _CONST._DIRECTIONS._DOWN;
        }

        // default positionDelta = 0
        if (options.direction === _CONST._DIRECTIONS._DOWN && !Object.prototype.hasOwnProperty.call(options, "positionDelta")) {
            options.positionDelta = 0;
        }

        if (options.selfExecute === true) {
            // if the Leaf has a "handle<name>" method with the first letter of
            // name in Capital it runs it
            const handlingMethodName = `handle${helper.jsUcfirst(name)}`;
            const capable = typeof this[handlingMethodName] === 'function';

            if (capable) {
                const response = this[handlingMethodName](target, payload);
                if (response !== _CONST._BYPASS) {
                    const result = {
                        response: response,
                        responder: this
                    };
                    if (options.direction === _CONST._DIRECTIONS._UP) {
                        return result;
                    }
                    else {
                        return [{ ...result, positionDelta: options.positionDelta }];
                    }
                }
            }
        }

        if (options.direction === _CONST._DIRECTIONS._UP) {
            if (this.hasParent) {
                return this.parentNode.putMessageOnPipe(name, payload, target, { selfExecute: true, direction: _CONST._DIRECTIONS._UP });
            }
            else { // if the message reaches the top of the tree without finding any liable target
                return {
                    response: false,
                    responder: null
                }
            }
        }
        else { // _CONST._DIRECTIONS._DOWN
            return []
        }
    }

    bypass() {
        return _CONST._BYPASS;
    }

}

module.exports = Leaf;
