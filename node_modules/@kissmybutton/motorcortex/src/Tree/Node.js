const Leaf = require('./Leaf');
const _CONST = require('./_CONST');
const _COPY = require('./_copy');
const systoleDiastole = require('./decorators/systoleDiastole');

class Node extends Leaf {
    constructor(props = {}) {
        super(props);

        this.isNode = true;

        /**
          The object holds the Incidents of the Scene on the format:
          {
              <id>: {
                    id // the id of the Incident object
                    leaf // the incident object
                    position // the position of the incident
              },
              ...
          }
           */
        this.children = {};

        this.calculatedDuration = 0;
    }

    get duration() {
        return this.calculatedDuration;
    }

    set duration(newDuration) {
        const durationFraction = newDuration / this.duration;

        if (this.props) {
            if (Object.prototype.hasOwnProperty.call(this.props, "duration")) {
                this.props.duration = newDuration;
            }
        }

        this.calculatedDuration = newDuration;

        for (let childKey in this.children) {
            const child = this.children[childKey];
            this.editPosition(child.id, child.position * durationFraction, true);
            child.leaf.systoleDiastole(durationFraction);
        }
    }

    setNewDuration(newDuration) {
        this.duration = newDuration;
        this.putMessageOnPipe('recalcDuration', {}, 'Groups', { selfExecute: false, direction: _CONST._DIRECTIONS._UP });
    }

    _calculateDuration() {
        let duration = 0;
        for (let childKey in this.children) {
            const child = this.children[childKey];
            if (child.position + child.leaf.duration > duration) {
                duration = child.position + child.leaf.duration;
            }
        }

        if (duration === this.calculatedDuration) {
            return false;
        }

        if (this.props) {
            if (Object.prototype.hasOwnProperty.call(this.props, "duration")) {
                this.props.duration = duration;
            }
        }

        this.calculatedDuration = duration;

        return true;
    }

    @systoleDiastole
    systoleDiastole() {}

    handleRecalcDuration(target, payload) { // eslint-disable-line no-unused-vars
        if (this._calculateDuration()) {
            return this.putMessageOnPipe('recalcDuration', {}, 'Groups', { selfExecute: false, direction: _CONST._DIRECTIONS._UP });
        }
        return true;
    }

    getLeafById(id, onlyDirectChild = false) {
        if (Object.prototype.hasOwnProperty.call(this.children, id)) {
            return this.children[id].leaf;
        }
        else if (onlyDirectChild === false) {
            for (let child in this.children) {
                const childLeaf = this.children[child].leaf;
                if (childLeaf.isNode) {
                    let leaf = childLeaf.getLeafById(id);
                    if (leaf != null) {
                        return leaf;
                    }
                }
            }
        }
        else {
            return null;
        }

        return null;
    }

    getLeafPosition(id) {
        return this.children[id].position;
    }

    checkAddition(leaf, position) {
        if (leaf.hasParent) {
            return {
                result: false,
                reason: _COPY._LEAFALREADYASSIGNED
            };
        }

        if (position < 0) {
            return {
                result: false,
                reason: _COPY._NEGATIVEPOSITIONNOTALLOWED
            };
        }

        return {
            result: true
        };

    }

    addChild(leaf, position) {
        // this hasParent check occurs here as an extra security check so it
        // gets executed regardless if the user wants to perform checks or not
        if (leaf.hasParent) {
            return {
                result: false,
                reason: _COPY._LEAFALREADYASSIGNED
            };
        }

        this.children[leaf.id] = {
            id: leaf.id,
            leaf: leaf,
            position: position
        };

        leaf.attachToNode(this);
        this.putMessageOnPipe('recalcDuration', {}, 'Groups', { selfExecute: true, direction: _CONST._DIRECTIONS._UP });
        return {
            result: true
        }
    }

    checkRemoveChild(id) {
        if (!Object.prototype.hasOwnProperty.call(this.children, id)) {
            return {
                result: false,
                reason: _COPY._LEAFNOTFOUND
            };
        }

        return {
            result: true
        }
    }

    removeChild(id) {
        this.children[id].leaf.detachFromParent();
        delete this.children[id];

        this.putMessageOnPipe('recalcDuration', {}, 'Groups', { selfExecute: true, direction: _CONST._DIRECTIONS._UP });
        return {
            result: true
        };
    }

    checkEditPosition(id, position) {
        if (position < 0) {
            return {
                result: false,
                reason: _COPY._NEGATIVEPOSITIONNOTALLOWED
            }
        }

        if (!Object.prototype.hasOwnProperty.call(this.children, id)) {
            return {
                result: false,
                reason: _COPY._LEAFNOTFOUND
            };
        }

        return {
            result: true
        }
    }

    editPosition(id, position, bypassRecalcDuration = false) {
        if (Object.prototype.hasOwnProperty.call(this.children, id)) {
            this.children[id].position = position;
            if (bypassRecalcDuration === false) {
                this.putMessageOnPipe('recalcDuration', {}, 'Groups', { selfExecute: true, direction: _CONST._DIRECTIONS._UP });
            }

            return {
                result: true
            }
        }
    }


    /**
    The expected result of this method depends on the direction of the message
    The direction might either be _UP or _DOWN.
    In the case of _UP the expected result is identical as on Leaf:
    {
        response: an object the structure of which depends on the name of the message
            and maybe even on the payload
        responder: a direct reference to the lead that actually responded
    }
    In the case of _DOWN though, where multiple Leafs might be eligible in the tree
    for handling the message the result is on the form:
    [
        {
            response: an object the structure of which depends on the name of the message
                and maybe even on the payload
            responder: a direct reference to the lead that actually responded
            positionDelta: the position delta of the responder compared to the requester
        }
    ]
    */
    putMessageOnPipe(name, payload, target, options = {}) {
        // default direction: _DOWN
        if (!Object.prototype.hasOwnProperty.call(options, 'direction')) {
            options.direction = _CONST._DIRECTIONS._DOWN;
        }

        // default positionDelta = 0
        if (options.direction === _CONST._DIRECTIONS._DOWN && !Object.prototype.hasOwnProperty.call(options, 'positionDelta')) {
            options.positionDelta = 0;
        }

        if (options.direction === _CONST._DIRECTIONS._UP) { // if the direction is up
            return super.putMessageOnPipe(name, payload, target, options); // act exactly as any other Leaf
        }
        else {
            let result = super.putMessageOnPipe(name, payload, target, options);
            if (result.length > 0) {
                return result;
            }

            for (let child in this.children) {
                const leaf = this.children[child].leaf;
                const newOptions = { ...options, selfExecute: true, positionDelta: options.positionDelta + this.children[child].position };
                result = result.concat(leaf.putMessageOnPipe(name, payload, target, newOptions));
            }

            return result;
        }
    }

}

module.exports = Node;
