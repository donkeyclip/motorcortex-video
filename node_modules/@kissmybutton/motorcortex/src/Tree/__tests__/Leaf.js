const _CONST = require('../_CONST');
const Leaf = require('../Leaf');
const Node = require('../Node');
const plainLeaf = new Leaf({ id: 'plain-leaf' });
const node = new Node();
class HandlerLeaf extends Leaf {
    handleTestMessage(target, payload) {
        if (payload === 1 && target === 'foo-target') {
            return true;
        }
        else {
            return this.bypass();
        }
    }
}
const handlerLeaf = new HandlerLeaf({ duration: 1000 });


test('should generate an id if it is not provided on the props', () => {
    expect(handlerLeaf.id).toHaveLength(18);
});

test('should return the failed payload for _UP messages when it does not belong to a tree and selfExecute=true', () => {
    expect(plainLeaf.putMessageOnPipe('foo', {}, 'foo-target', { selfExecute: true, direction: _CONST._DIRECTIONS._UP })).toEqual({
        response: false,
        responder: null
    });
});

test('should return an empty payload for _DOWN messages when it does not belong to a tree and selfExecute=true', () => {
    expect(plainLeaf.putMessageOnPipe('foo', {}, 'foo-target', { selfExecute: true, direction: _CONST._DIRECTIONS._DOWN })).toEqual([]);
});

test('should return the failed payload for _UP messages when it does not belong to a tree and selfExecute=false', () => {
    expect(plainLeaf.putMessageOnPipe('foo', {}, 'foo-target', { selfExecute: true, direction: _CONST._DIRECTIONS._UP })).toEqual({
        response: false,
        responder: null
    });
});

test('should return an empty array for _DOWN messages when it does not belong to a tree and selfExecute=false', () => {
    expect(plainLeaf.putMessageOnPipe('foo', {}, 'foo-target', { selfExecute: true, direction: _CONST._DIRECTIONS._DOWN })).toEqual([]);
});

test('should return true for _UP messages for a message it (conditionally) handles and selfExecute=true', () => {
    const res = handlerLeaf.putMessageOnPipe('testMessage', 1, 'foo-target', { selfExecute: true, direction: _CONST._DIRECTIONS._UP });
    expect(res.responder).toEqual(handlerLeaf);
    expect(res.response).toBe(true);
});

test('should return the failed payload for _UP messages for a message that it (conditionally) does not hanlde and selfExecute=true', () => {
    const res = handlerLeaf.putMessageOnPipe('testMessage', 0, 'foo-target', { selfExecute: true, direction: _CONST._DIRECTIONS._UP });
    expect(res).toEqual({
        response: false,
        responder: null
    });
});

test('should return a response array for _DOWN messages for a message it (conditionally) handles and selfExecute=true', () => {
    const res = handlerLeaf.putMessageOnPipe('testMessage', 1, 'foo-target', { selfExecute: true, direction: _CONST._DIRECTIONS._DOWN });
    expect(res).toHaveLength(1);
    expect(res[0].responder).toEqual(handlerLeaf);
    expect(res[0].response).toBe(true);
});

test('should return an empty array for _DOWN messages for a message that it (conditionally) does not hanlde and selfExecute=true', () => {
    const res = handlerLeaf.putMessageOnPipe('testMessage', 0, 'foo-target', { selfExecute: true, direction: _CONST._DIRECTIONS._DOWN });
    expect(res).toEqual([]);
});

test('should return the failed payload for _UP messages for a message that it (conditionally) hanldes when selfExecute=false', () => {
    const res = handlerLeaf.putMessageOnPipe('testMessage', 1, 'foo-target', { selfExecute: false, direction: _CONST._DIRECTIONS._UP });
    expect(res).toEqual({
        response: false,
        responder: null
    });
});

test('should return an empty array for _DOWN messages for a message that it (conditionally) hanldes but selfExecute=false', () => {
    const res = handlerLeaf.putMessageOnPipe('testMessage', 1, 'foo-target', { selfExecute: false, direction: _CONST._DIRECTIONS._DOWN });
    expect(res).toEqual([]);
});

test('should assign its parent when added to a Node', () => {
    node.addChild(plainLeaf, 2000);
    expect(plainLeaf.parentNode).toBe(node);
    expect(plainLeaf.hasParent).toBe(true);
});

test('should release its parent when removed from a Node', () => {
    node.removeChild(plainLeaf.id);
    expect(plainLeaf.parentNode).toBe(null);
    expect(plainLeaf.hasParent).toBe(false);
});
