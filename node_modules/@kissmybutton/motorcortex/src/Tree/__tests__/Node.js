const _CONST = require('../_CONST');
const _COPY = require('../_copy');
const Leaf = require('../Leaf');
const Node = require('../Node');

class TestNode extends Node {
    handleRootRequest(target, payload) { // eslint-disable-line no-unused-vars
        if (target === _CONST._TARGETTYPES._ROOTOFTREE) {
            return this.id;
        }
    }
}

const testNode = new TestNode({ id: 'test-node' });
const node = new Node();
const plainNode = new Node({ id: 'plain-node' });
const plainNodeTwo = new Node({ id: 'plain-node-two' });

class TestLeaf extends Leaf {
    handleGather(target, payload) { // eslint-disable-line no-unused-vars
        if (this.isEligible !== true) {
            return this.bypass();
        }

        return this.id;
    }
}
const _leafA = new TestLeaf({ id: '_leafA' });
_leafA.isEligible = true;
const _leafB = new TestLeaf({ id: '_leafB' });
_leafB.isEligible = true;
const leafA = new TestLeaf({ id: 'leafA' });
const leafB = new TestLeaf({ id: 'leafB' });

/*************************** ID ASSIGNMENT *************************************/
test('should generate an id if it is not provided on the props', () => {
    expect(node.id).toHaveLength(18);
});


/*********************** NULL TARGET WHILE BEING FREE *******************************/
test('should return the failed payload for _UP messages when it does not belong to a tree and selfExecute=true', () => {
    expect(plainNode.putMessageOnPipe('foo', {}, 'foo-target', { selfExecute: true, direction: _CONST._DIRECTIONS._UP })).toEqual({
        response: false,
        responder: null
    });
});

test('should return an empty payload for _DOWN messages when it does not belong to a tree and selfExecute=true', () => {
    expect(plainNode.putMessageOnPipe('foo', {}, 'foo-target', { selfExecute: true, direction: _CONST._DIRECTIONS._DOWN })).toEqual([]);
});

test('should return the failed payload for _UP messages when it does not belong to a tree and selfExecute=false', () => {
    expect(plainNode.putMessageOnPipe('foo', {}, 'foo-target', { selfExecute: true, direction: _CONST._DIRECTIONS._UP })).toEqual({
        response: false,
        responder: null
    });
});

test('should return an empty array for _DOWN messages when it does not belong to a tree and selfExecute=false', () => {
    expect(plainNode.putMessageOnPipe('foo', {}, 'foo-target', { selfExecute: true, direction: _CONST._DIRECTIONS._DOWN })).toEqual([]);
});


/************************** ADDING LEAFS TO NODES ****************************/
test('check addition should pass', () => {
    expect(node.checkAddition(plainNode, 2000)).toEqual({
        result: true
    });
});

test('should assign its parent when added to a Node. Also, parent should add the leaf in its children', () => {
    node.addChild(plainNode, 2000);
    expect(node.children[plainNode.id].leaf).toBe(plainNode);
    expect(node.children[plainNode.id]).toEqual({
        id: plainNode.id,
        leaf: plainNode,
        position: 2000
    });
});

test('check addition should not pass because leaf already belongs to parent', () => {
    expect(node.checkAddition(plainNode, 2000)).toEqual({
        result: false,
        reason: _COPY._LEAFALREADYASSIGNED
    });
});


test('check addition should not pass because of a negative position', () => {
    plainNodeTwo.id = 'plain-node-two';
    expect(node.checkAddition(plainNodeTwo, -200)).toEqual({
        result: false,
        reason: _COPY._NEGATIVEPOSITIONNOTALLOWED
    })
});

/************************** _DOWN MESSAGE ****************************************/
test('Gather responses from eligible Leafs', () => {
    plainNode.addChild(leafA, 1000);
    plainNode.addChild(leafB, 2000);
    plainNode.addChild(_leafA, 3000);
    plainNode.addChild(_leafB, 4000);

    const res = node.putMessageOnPipe('gather', {}, {}, { selfExecute: true, direction: _CONST._DIRECTIONS._DOWN });
    expect(res).toEqual([{
            response: '_leafA',
            responder: _leafA,
            positionDelta: 5000
        },
        {
            response: '_leafB',
            responder: _leafB,
            positionDelta: 6000
        }
    ]);
});

/************************* UP MESSAGE TARGETING ROOT ****************************/
test('should not get back an answer as the root is not eligible to handle the root request', () => {
    const res = leafA.putMessageOnPipe('rootRequest', {}, _CONST._TARGETTYPES._ROOTOFTREE, { selfExecute: false, direction: _CONST._DIRECTIONS._UP });
    expect(res).toEqual({
        response: false,
        responder: null
    })
});

test('should get back an answer as the root is now eligible to handle the root request', () => {
    testNode.addChild(node, 2000);
    const res = leafA.putMessageOnPipe('rootRequest', {}, _CONST._TARGETTYPES._ROOTOFTREE, { selfExecute: false, direction: _CONST._DIRECTIONS._UP });
    expect(res).toEqual({
        response: 'test-node',
        responder: testNode
    })
});


/************************** GET LEAF BY ID ***************************************/
test('should return the leaf by ID', () => {
    const res = testNode.getLeafById('_leafA');
    expect(res).toEqual(_leafA);
})

/************************** REMOVING LEAFS FROM NODES ****************************/
test('should return error when trying to remove a Leaf that does not exist', () => {
    expect(node.checkRemoveChild('not-existing-id')).toEqual({
        result: false,
        reason: _COPY._LEAFNOTFOUND
    });
})

test('should release its parent when removed from a Node. Also, parent should remove the leaf from its children', () => {
    node.removeChild(plainNode.id);
    expect(plainNode.parentNode).toBe(null);
    expect(plainNode.hasParent).toBe(false);
});

/*********************** EDIT POSITION *******************************/
test('should not allow position edit when negative position is provided', () => {
    const res = plainNode.checkEditPosition('leafA', -150);
    expect(res).toEqual({
        result: false,
        reason: _COPY._NEGATIVEPOSITIONNOTALLOWED
    });
});

test('trying to edit position on an non-existing id should return error', () => {
    const res = plainNode.checkEditPosition('non-existing', 150);
    expect(res).toEqual({
        result: false,
        reason: _COPY._LEAFNOTFOUND
    })
})

test('succesfull editing position', () => {
    const check = plainNode.checkEditPosition('leafB', 5000);
    const res = plainNode.editPosition('leafB', 5000);
    expect(check).toEqual({
        result: true
    });

    expect(res).toEqual({
        result: true
    });

    expect(plainNode.children.leafB).toEqual({
        id: 'leafB',
        leaf: leafB,
        position: 5000
    });
})
